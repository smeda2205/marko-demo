'use strict';

var CAL = require('cal');
var assert = require('assert');
var config = require('./config');
var objutil = require('objutil');
var util = require('util');

var LOG_LEVELS = config.LOG_LEVELS;

var lastConfigChangeTimestamp = Date.now();

config.on('change', function () {
    lastConfigChangeTimestamp = Date.now();
});

function Logger(options) {
    if (typeof options === 'string') {
        options = { name: options };
    }
    options = this._options = options || {};
    this.cal = CAL.createLogger(options);
    var name = this.name = options.name || 'root';
    refreshLogLevels(this);
}

/**
 * General log method
 * @param loglevel specifies log level in lower case (debug, info, warn, error, fatal)
 * @param type is default type correspoding to log level
 * @param format {string} is format string or message, optional
 * @param data is unlimited set of arguments, optional
 * @param error is Error object, optional
 */
Logger.prototype.log = function log(/* format, arg1, arg2, ... */) {
    refreshLogLevels(this);
    CAL.start();

    var args = Array.prototype.slice.call(arguments);
    var loglevel = args.shift();
    if (!this._loglevels[loglevel]) {
        return nil();
    }

    var logger = this.cal;
    var type = args.shift();
    type = this._options && this._options.type || type;
    var name = this.name;
    var msg;

    // find first error if any and use it as a primary error with the state/code
    var error;
    for (var i = 0; i < args.length; i++) {
        if (args[i] instanceof Error) {
            error = args[i];
            if (!i) { // if error is a first ergument, then take error.message as a message
                msg = error.message;
            }
            args.splice(i, 1);
            break;
        }
    }

    if (msg) {
        args.unshift(msg);
    }

    msg = util.format.apply(util, args);

    var event = logger.createEvent(type, name);

    if (error) {
        event.addData(msg, error && error.stack || error);
    }
    else if (msg) {
        event.addData(msg);
    }

    event.__doGetEventArgs = event._doGetEventArgs;
    event._doGetEventArgs = function () {
        var args = event.__doGetEventArgs() || {};
        args.loglevel = loglevel;
        return args;
    };

    var isError = ['error', 'fatal'].indexOf(loglevel) !== -1;
    var hasError = error && (isError || loglevel === 'warn');
    var eventName = event.name;
    var parentEvent = event.parent;
    if (parentEvent && parentEvent.name) {
        if (hasError) {
            eventName = parentEvent.name;
        }
        else if ((loglevel === 'warn' ||
            loglevel === 'info')) {
            event.type = parentEvent.name;
        }
    }
    if (hasError) {
        eventName += '_' + (event.status && event.status !== '0' &&
            event.status || error.statusCode || error.code || 'Error');
        event.name = eventName;
    }

    event.complete(event.status && event.status !== '0' && event.status ||
        (hasError ? error && (error.statusCode || error.code) || 1 : 0));

    return event;
};

Logger.prototype.isLogLevelEnabled = function isLogLevelEnabled(loglevel) {
    return this._loglevels[loglevel];
};

/**
 * Can be used to profile specific methods of the object.
 */
Logger.prototype.profile = function profile(obj, method, loglevel) {
    if (!this.isLogLevelEnabled(loglevel || 'info')) {
        return;
    }

    var _this = this;
    var orig = obj[method];

    obj[method] = function () {
        var args, callback;

        args = arguments;
        callback = args[args.length - 1];

        if (typeof callback === 'function') {
            _this.begin('profile', method, function (tx) {
                args[args.length - 1] = function () {
                    tx.end();
                    callback.apply(undefined, arguments);
                    obj[method] = orig;
                };
            });
            orig.apply(obj, args);
        }
        else {
            var tx = _this.begin('profile', method);
            try {
                orig.apply(obj, args);
            }
            finally {
                tx.end();
            }
        }
    };
};

/**
 * Sets the event type to be used in logging, optional, used for CAL logging.
 * By default it will use predefined types corresponding to the log level.
 */
Logger.prototype.type = function createType(type) {
    return new Logger(objutil.mixin(this._options, { type: type }));
};

/**
 * Logs event of type 'info'
 * @param param format is a format string similar to require('util').format
 * http://nodejs.org/api/util.html#util_util_format_format
 * @param data is unlimited set of arguments to be concatenated
*/
// info(format, data1, data2, ...);
Logger.prototype.info = function info() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift('info', 'Info');
    return this.log.apply(this, args);
};

/**
 * Logs event of type 'warn'
 * @param format {string} is format string or message
 * @param data is unlimited set of arguments
 * @param error {Error} is an optional error object
 */
// warn([[format], data1, data2, ..., ]error);
Logger.prototype.warn = function warn() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift('warn', 'Warn');
    return this.log.apply(this, args);
};

/**
 * Logs event of type 'error'
 * @param format {string} is format string or message
 * @param data is unlimited set of arguments
 * @param error {Error} is an optional error object
*/
// error([[format], data1, data2, ..., ]error);
Logger.prototype.error = function error() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift('error', 'Error');
    return this.log.apply(this, args);
};

/**
 * Logs event of type 'fatal'
 * @param format {string} is format string or message
 * @param data is unlimited set of arguments
 * @param error {Error} is an optional error object
*/
// fatal([[format], arg1, arg2, ..., ]error);
Logger.prototype.fatal = function fatal() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift('fatal', 'Fatal');
    return this.log.apply(this, args);
};

/**
 * Logs event of type 'debug'
 * @param format {string} is format string or message
 * @param data is unlimited set of arguments
*/
// debug([format], data1, data2, ...);
Logger.prototype.debug = function debug() {
    var args = Array.prototype.slice.call(arguments);
    args.unshift('debug', 'Debug');
    return this.log.apply(this, args);
};

Logger.prototype._createLoggerTxWrapper = function _createLoggerTxWrapper(tx) {
    var that = this;
    return {
        _ref: tx,
        /* no parameters */
        end: function end() {
            tx.complete(0);
            return tx;
        },
        addData: function addData() {
            tx.addData.apply(tx, arguments);
            return this;
        },
        /* message, Error, [status, data] */
        fail: function fail(message, error, status, data) {
            if (message instanceof Error) {
                var args = Array.prototype.slice.call(arguments);
                message = message.message;
                error = args.shift();
                status = args.shift();
                data = args.shift();
            }
            if (data) {
                tx.addData(data);
            }
            that.error(message, error || new Error('Unknown error'));
            tx._doComplete();
            tx.complete(status || error && (error.statusCode || error.code) || 1);
            return tx;
        }
    };
};

/**
 * Starts transaction
 * @param type {string} is transaction type, optional in case it was provided in the begin memthod.
 * @param name {string} is a name of the transaction, in case it was not provided in the begin method.
 * @param callback is callback function that will be in transaction context
*/
Logger.prototype.begin = function begin(type, name, callback) {
    var args = arguments;
    refreshLogLevels(this);
    if (!this._loglevels.transaction) {
        return nilTx.apply(null, args);
    }

    var that = this;

    var txCallback = callback !== undefined ? function txCallback(err, tx) {
        if (err) {
            console.error('Failed to create transaction', err.stack);
            return nilTx.apply(null, args);  // work as dummy transaction
        }
        if (callback !== undefined) {
            callback(that._createLoggerTxWrapper(tx));
        }
    } : null;

    var syncTx = this.cal.createTransaction(type, name, txCallback);

    if (callback === undefined) {
        return that._createLoggerTxWrapper(syncTx);
    }
};

module.exports.getLogger = module.exports.logger = function getLogger(options) {
    return new Logger(options);
};

objutil.mixin(config, module.exports);

function nil() {
    return {
        on: function () {}
    };
}
function nilTx() {
    var callback = arguments[arguments.length - 1];
    setImmediate(callback.bind(null, {
        addData: function () { return this; },
        fail: nil,
        end: nil
    }));
}

function refreshLogLevels(logger) {
    if (logger._updateTimestamp === lastConfigChangeTimestamp) {
        return;
    }
    logger._updateTimestamp = lastConfigChangeTimestamp;

    var loglevelEnabled = config.setupLogLevels(logger.name);
    logger._loglevels = {};
    for (var i = 0; i < LOG_LEVELS.length; i++) {
        var loglevel = LOG_LEVELS[i];
        logger._loglevels[loglevel] = !!(loglevelEnabled[loglevel] ||
            i && logger._loglevels[LOG_LEVELS[i - 1]]);
    }
}
