'use strict';


var path = require('path'),
    Os = require('os'),
    shell = require('shelljs'),
    tryRequire = require('try-require'),
    Tester = require('connection-tester'),
    HostipChecker = require('hostip-checker-ebay'),
    UtilsEbay = require('utils-ebay'),
    Async = require('async'),
    nodeVersion = process.versions.node || '0.0.0',
    majorMinor = nodeVersion.split('.'),
    major = parseInt(majorMinor[0], 10),
    minor = parseInt(majorMinor[1], 10),
    option = minor >= 10 ? {
        'encoding': 'utf8'
    } : 'utf8';

const debug = require('debug')('validate-internals-ebay:utils');
/*
    The port is used as a base in multi-process envirinment to target specific validate Internals
    endpoint listening on BASE_PORT + workerId, where workerId is pm_id environment variable
 */
const BASE_PORT = 10100;

exports.BASE_PORT = BASE_PORT;
exports.readFileOption = function readFileOption() {
    return option;
};

var debugInfo;

const cores = Os.cpus().length;
let maxWorkersIndex;

function _localSCMInfo() {
    var gitUrl,
        gitBranch,
        gitCommit,
        response;

    response = shell.exec('git config remote.origin.url', {silent: true});
    if (response && response.code === 0) {
        gitUrl = response.output.trim();
    }

    response = shell.exec('git rev-parse --abbrev-ref HEAD', {silent: true});
    if (response && response.code === 0) {
        gitBranch = response.output.trim();
    }

    response = shell.exec('git rev-parse HEAD', {silent: true});
    if (response && response.code === 0) {
        gitCommit = response.output.trim();
    }

    var scm = {
        gitUrl : gitUrl,
        gitBranch : gitBranch,
        gitCommit : gitCommit
    };
    return scm;
}

/*
 * Build Debug info
 * Read manifect.json for scm and version info
 * if this json file is missing (in local), using git commands build scm info
 */
exports.buidDebugInfo = function buidDebugInfo() {
    var root = process.cwd(),
        manifectJson = tryRequire(path.join(root, 'manifest.json'));

    if (!debugInfo) {
        if (manifectJson && manifectJson.scm) {
            debugInfo = {
                scm : manifectJson.scm,
                version : manifectJson.version
            };
        } else {
            debugInfo = {
                scm : _localSCMInfo()
            };
        }
    }
    return debugInfo;
};

exports.isDevRuntime = function isDevRuntime() {
    return process.env.pm_id === undefined;
};

function getWorkerId() {
    return process.env.pm_id || 0;
}
exports.getWorkerId = getWorkerId;

exports.getWorkersNumber = function getWorkersNumber() {
    updateWorkersMaxIndex();
    return process.env.pm_id === undefined ? 1 :
        // assume standard ebay box with 3 workers by default when no info is availabel yet
        (maxWorkersIndex !== undefined ? maxWorkersIndex + 1 : 3);
};

exports.getWorkerPorts = function getWorkerPorts() {
    updateWorkersMaxIndex();
    return workerPorts;
};

exports.getWorkerPort = function getWorkerPort(workerId) {
    if (workerId !== undefined) {
        return BASE_PORT + parseInt(workerId);
    }
    return BASE_PORT + parseInt(getWorkerId());
};

exports.isPortFree = function isPortFree(port, callback) {
    Tester.test('localhost', port, 1000, function (err, output) {
        callback(!!err);
    });
};

exports.getHeader = function getHeader(obj, name) {
    return obj.headers[name] || obj.headers[name.toLowerCase()];
};

exports.tryParse = function tryParse(value) {
    try {
        return JSON.parse(value);
    } catch (e) {
        return undefined;
    }
};

exports.round = function round(number, precision) {
    precision = precision || 0;
    var factor = Math.pow(10, precision);
    var tempNumber = number * factor;
    var roundedTempNumber = Math.round(tempNumber);
    return roundedTempNumber / factor;
};

let workersIndexDetection;
let workerPorts = [];
function updateWorkersMaxIndex() {
    workerPorts = [];

    if (cores > 1 && process.env.pm_id !== undefined) {

        if (workersIndexDetection) {
            return workersIndexDetection;
        }

        let max = 0;

        debug('# detecting max workers index, current number is', max);
        workersIndexDetection = new Promise(resolve => {
            Async.times(cores, (index, next) => {
                const port = BASE_PORT + index;
                debug('# checking port', port);
                Tester.test('localhost', port, 1000, function (err, output) {
                    if (err) {
                        return next();
                    }
                    max = Math.max(max, index);
                    workerPorts.push(port);
                    next();
                });
            }, () => {
                debug('# max workers index detected', max);
                // update
                maxWorkersIndex = max;
                resolve(max);
            });

            // trottle worker detection
            // clean up promise/queue after 10 seconds
            setTimeout(() => {
                workersIndexDetection = undefined;
            }, parseInt(process.env.TROTTLE_WORKER_DETECTION_INTERVAL) || 10000);

        });
        return workersIndexDetection;
    }

    return Promise.resolve(maxWorkersIndex);
}

exports.updateWorkersMaxIndex = updateWorkersMaxIndex;

// Returns true if IP is internal, else false.
function allowView(req) {
    var ip = UtilsEbay.getRemoteAddr(req);
    var chk = HostipChecker.checkIpSync(ip);
    if (chk && chk.isInternal && !UtilsEbay.isIPFromAkamaiHeader(req)) {
        return true;
    }
    return false;
}
exports.allowView = allowView;

function getPort(req) {
    return req.app && req.app.get('port') ||
        req.socket && req.socket.localPort || 0;
}
exports.getPort = getPort;
