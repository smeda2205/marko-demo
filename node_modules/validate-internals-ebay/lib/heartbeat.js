'use strict';

/* Delivers heartbeats to CAL for PERFMON. It is triggered
 * every time monitor-inc sends data to Sherlock. Normally,
 * this will be once per minute. Data values mostly derive
 * from the metrics being reported by monitor-inc to Sherlock.
* For now, the AutoStresser tool can only monitor CAL heartbeats
* and not Sherlock so we must log the same metrics to two places.
*/

// Node heaps can get a bit larger (around 1.4GB) but monitor-inc
// will restart the process if 1.2GB is exceeded as using up the
// last bit of heap leads to excessive GCing and little work getting done.
var MAX_NODE_MEM = 1.2e9;  // 1.2GB

var cal = require('cal'),
    os = require('os'),
    tryRequire = require('try-require'),
    Monitor = tryRequire('monitor-inc'),
    freemem,
    cpu,
    lastStats = {cpu: 0};

// Event triggered by monitor-inc
// Note: If monitor-inc is not present, no heartbeats will be
// emitted to CAL. A separate interval timer could be added
// here to deal with this but hopefully monitor- will be on.
if (Monitor) {
    Monitor.on('monitorStats', function (stats) {
        lastStats = stats;
        // monitor-inc sends heap_used in KBs. *1000 gives us bytes again
        // (1.2GBbytes - heap_used in bytes) = remaining bytes free
        // Perfmon expects jvmMemAvailable to be in bytes
        freemem = MAX_NODE_MEM - (stats.heap_used*1000);
        cpu = Math.round(isNaN(stats.cpu) ? 0 : stats.cpu);
        var upHrs = process.uptime() / 3600;

        var hb = cal.createHeartbeat('PerfMon', 'OS');
        hb.addData('cpuUsage', cpu);
        hb.addData('jvmCpuUsage', cpu);
        hb.addData('jvmMemoryUsed', stats.heap_used*1000);
        hb.addData('jvmMemAvail', freemem);
        hb.addData('jvmMemTotal', MAX_NODE_MEM);
        hb.addData('jvmVirtualBytes', MAX_NODE_MEM);
        hb.addData('osName', os.type());
        hb.addData('appServer', 'node ' + process.version);
        hb.addData('jdk','64');
        hb.addData('numProcessors', os.cpus().length);
        hb.addData('serverUpHrs', upHrs);
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'GC');
        hb.addData('gccount', stats.gc_count);
        // Convert percentage value to integer (.05 -> 5) to match expected form
        hb.addData('gcovhdx10', Math.round(stats.gcInterval*100));
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'THREAD');
        hb.addData('appserverBusyThreads', stats.noWorkers);
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'TPS');
        hb.addData('tps', Math.round(stats.tps));
        hb.addData('transactionTime', Math.round(stats.urlTime ? stats.urlTime.toFixed(2) : 0));
        hb.addData('javaCpuTime', cpu);
        // the fallback from errorCount to eps is temporary for backwards compatibility due to dependency on 
        // monitor-inc module, TODO: if you are working on this module, you can remove Math.round(stats.eps) from
        // the bleow statement
        hb.addData('errorCount', stats.errorCount || Math.round(stats.eps) || 0);
        hb.addData('oomErrorCount', stats.oomError || 0);
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'RESTARTS');
        hb.addData('restartCount', stats.restarts || 0);
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'HttpStatusMetrics');
        hb.addData('m:resSecs', 60);
        hb.addData('g:4XXCount', stats.http4XX);
        hb.addData('g:unknownStatusCode', 0);
        hb.addData('g:3XXCount', stats.http3XX);
        hb.addData('g:2XXCount', stats.http2XX);
        hb.addData('g:5XXCount', stats.http5XX);
        hb.complete();

        hb = cal.createHeartbeat('PerfMon', 'SecurityViolation');
        hb.addData('csrf', stats.csrf || 0);
        hb.addData('redirect', stats.redirect || 0);
        hb.addData('csp', stats.csp || 0);
        hb.addData('xss', stats.xss || 0);
        hb.complete();

    });
}

module.exports.getMetrics = function getMetrics() {
    return lastStats;
};
