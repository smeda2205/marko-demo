'use strict';

// TODO Need to validate that request originates within eBay and for update
// command that the IP is allowed to issue config updates.

var defaultComponents = require('./default-components'),
    renderers = require('./renderers'),
    express = require('express'),
    path = require('path'),
    fs = require('graceful-fs'),
    _ = require('underscore'),
    configBean = require('config-bean-ebay'),
    hostipChecker = require('hostip-checker-ebay'),
    cal = require('cal'),
    util = require('util'),
    profiler = require('v8-profiler'),
    metaModel = require('meta-inc/lib/metaModel'),
    dependencyTreeModel = require('meta-inc/lib/dependencyTree'),
    path = require('path'),
    utils = require('utils-ebay'),
    ViUtils = require('./utils.js'),
    Prxy = require('./proxy'),
    readFileOption = ViUtils.readFileOption,
    urllib = require('url');

const allowView = ViUtils.allowView;
// Initialize default components for SiteValidator
var componentStatus = require('./component-status.js');
defaultComponents.initSiteValidatorComponents();

var logFolder = path.join(process.cwd(), './logs');
var memoryDumpState;
var cpuProfileInProgress;

var CHANNEL_STATUS = {
   0: 'INITIAL_MARK_DOWN',
   1: 'MARK_UP',
   2: 'OPS_MARK_DOWN',
   3: 'OPS_EXTERNAL_PERSIS_MARK_DOWN',
   4: 'APP_AUTO_MARK_DOWN'
};

// Allow ECV requests and assume ready for traffic
//TODO is there a better place to do this where we know things
// are truly ready?
componentStatus.enableComponentStatus();

var monApp = module.exports = express();

// Setup static resource serving for js, css, images, xsl
monApp.use('/js', express.static(path.join(__dirname, './public/scripts')));
monApp.use('/css', express.static(path.join(__dirname, './public/stylesheets')));
monApp.use('/v3console/resources/xsl', express.static(path.join(__dirname, './public/transforms')));
monApp.use('/images/vi', express.static(path.join(__dirname, './public/images')));
monApp.use('/css/smoothness/images', express.static(path.join(__dirname, './public/images')));
monApp.use('/hystrix', require('./hystrix'));

monApp.engine('.ejs', require('ejs').__express);
monApp.set('views', path.join(__dirname, './public/views'));
monApp.set('view engine', 'ejs');
monApp.use(require('body-parser').urlencoded({
  extended: true
}));

// Routes supported by ValidateInternals
monApp.get('/v3console/ValidateInternals(2)?', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    var component = req.query.component,
        view = req.query.view;

    //if component, go to component status, otherwise show the index page
    if (!component || component === 'hostInformation' ||
        component === 'hostinformation' || component === 'Host Information') {
        renderers.renderDefaultComponentStatus(req, res);
    }
    else if (component === 'Troubleshooting Info') {
        renderers.renderTroubleshooting(req, res);
    }
    else if (component === 'Environment Properties') {
        renderers.renderEnvironmentProperties(req, res);
    }
    else if (component === 'serviceclientstatus' || component === 'Service Client') {
        renderers.renderServiceComponentsTree(req, res);
    }
    else if (!_.contains(componentStatus.getComponents(), component)) {

        res.status(404).send('no such component ' + component);
    }
    else {
        renderers.renderComponentStatus(req, res);
    }

});

monApp.get('/v3console/ViewConfigCategoryList', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    if (proxyIfRequested(req, res)) {
        return;
    }

    renderers.renderConfigCategoryList(req, res);
});

monApp.get(/^\/v3console\/ViewConfigCategory(Xml)?/, function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    // Be sure all beans on disk are also reflected in memory. Some other
    // instance may have created one that we are unaware of and have no
    // file watch on yet.
    configBean.syncDiskBeans();
    renderers.renderConfigBean(req, res);
});

monApp.get(/^\/v3console\/UpdateConfigCategory(Xml)?/, updateConfigCategory);
monApp.post(/^\/v3console\/UpdateConfigCategory(Xml)?/, updateConfigCategory);

function updateConfigCategory(req, res) {
    if (!allowUpdate(req, res)) {
        res.status(403).send('ValidateInternals update not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    var query = req.query,
        id = query.id,
        clear = query.clear,
        value = _.omit(query, 'id', 'forceXml', 'clear');

    var bean = configBean.getBeanById(id);
    if (!bean) {
        res.status(404).send('no such configbean ' + id);
    } else {
        // For multiple node instances. Force this instance
        // to load all beans just to be sure we have them all and have
        // file watchers on them.
        configBean.syncDiskBeans();
        var upd = cal.createHeartbeat('UPDATE_VI', id);
        if (clear === 'true') {
            upd.addData('resetBean', id);
            bean.reset();

        } else {
            // Set possibly multiple changed values
            for (var name in value) {
                var keyval = value[name];
                if(name === 'SVC_CHANNEL_STATUS' && CHANNEL_STATUS[keyval]) {
                    keyval = CHANNEL_STATUS[keyval];
                }
                var result = bean.set(name, keyval); //set new value
                upd.addData('prop', name);
                upd.addData('value', keyval);
                upd.addData('oldValue', result);
                upd.complete();
                if (result instanceof Error) {
                    res.status(403).send(result);
                    upd.complete();
                    return;
                }
            }
        }
        upd.complete();
        renderers.renderConfigBean(req, res); //redisplay changed bean
    }
}


monApp.get('/v3console/ComponentStatus(List)?', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    if (proxyIfRequested(req, res)) {
        return;
    }

    renderers.renderComponentStatusList(req, res);
});

monApp.get('/v3console/logs', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    var logfile = req.query.logfile;

    if (!logfile) {
        fs.readdir(logFolder, function (err, files) {
            if (files) {
                var logs = files.map(function (file) {
                    var stats = fs.statSync(path.join(logFolder, file));
                    return {
                        'text': file,
                        'link': '/admin/v3console/logs?logfile=' + file,
                        'mtime': stats.mtime,
                        'size': stats.size
                    };
                });
                res.type('html').render('line-reader', {
                    'links': logs
                });
            } else {
                res.type('text').send("No log files found");
            }
        });
    } else {

        //Use only real file name and strip any directories
        logfile = path.basename(logfile);
        //assuming the logs path as './logs/ebay.log'
        fs.exists(path.join(logFolder, logfile), function (exists) {
            if (exists) {
                var rstream = fs.createReadStream(path.join(logFolder, logfile));
                rstream.pipe(res);
            } else {
                res.send("Log file does not exist:" + logfile);
            }
        });
    }
});


monApp.get('/v3console/meta', function (req, res) {
    var model = {};
    // Get route/middleware stack from parent app as we are a subapp
    // Note: require must be done here rather than at top. Matter of timing.
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    metaModel.getModel(req, res, model, function (err, model) {
        res.setHeader('Cache-Control', 'no-cache');
        res.json(model);
    });
});

monApp.get('/v3console/modules', function (req, res) {
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    dependencyTreeModel.getDependencyTree(function (err, treePath) {
        if(err) {
            return res.send(err);
        }
        fs.createReadStream(treePath).pipe(res);
    });
});

monApp.post('/v3console/profile', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    // sanitize in case someone tries to access root dir, make it bad
    var profilePath = process.cwd() + '/logs/' + req.body.file.replace('\/', '');
    if (fs.existsSync(profilePath)) {
        fs.unlink(profilePath);
    }

    res.redirect('profile?type=' + req.body.type);
});

monApp.get('/v3console/profile', function (req, res) {
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }

    if (proxyIfRequested(req, res)) {
        return;
    }

    var base = process.cwd() + '/logs';
    if (!fs.existsSync(base)) {
        fs.mkdirSync(base);
    }

    switch (req.query.type) {
        case 'cpu':
            if (!handleCpuProfileRequest(req, res)) {
                // in case profiling is in progress
                return;
            }
            break;
        case 'memory':
            handleMemoryProfileRequest(req);
            if (req.query.start === 'true') {
                res.redirect('profile?type=' + req.query.type);
                return;
            }
            break;
        default:
            return res.status(400).send('Bad request');
    }

    renderers.renderProfilePage(req, res);
});
monApp.get('/v3console/servicehostlist', function (req, res) {
    var parentApp = require('./index').getParentApp();
    req.routeStack = parentApp && parentApp._router && parentApp._router.stack;
    if (!allowView(req, res)) {
        res.status(403).send('ValidateInternals not allowed');
        return;
    }
    var hostlist = getServiceHostList();
    res.setHeader('Cache-Control', 'no-cache');
    res.json(hostlist);
});
function getServiceHostList(){
    var beanList = configBean.getConfigBeanList(),
        hostlist = [];
    beanList.forEach( function (name, cb) {
        var theBean = configBean.getBeanById(name);
        var attrs = theBean.getAttributes();
        if (attrs) {
            var url ;
            var defaultUrl ;
            var hostname ;
            var status ;
            status = theBean.get('SVC_CHANNEL_STATUS');
            // filer out only components that represent service by using SVC_CHANNEL_STATUS field as an indication of this
            if (status) {
                url = theBean.get('ENDPOINT_URL');
                defaultUrl = theBean.get('DEFAULT_ENDPOINT_URL');
                hostname = theBean.get('hostname');
                url = url || defaultUrl;
                if (url && url.indexOf('http') > -1){
                    url = urllib.parse(url).hostname;
                }
                var host = url ||defaultUrl || hostname;
                if (host && hostlist.indexOf(host) < 0 ) {
                    hostlist.push(host);
                }
            }
        }
    });
    return hostlist;
}

function handleMemoryProfileRequest(req) {
    var dumpsNumber = parseInt(req.query.dumps, 10) || 2;
    var intervalRequested = parseInt(req.query.interval, 10) || 10;
    var units = req.query.units || 'min';
    var start = req.query.start;
    var base = process.cwd() + '/logs';
    var workerId = ViUtils.getWorkerId();

    if (start === 'true') {
        var interval = intervalRequested * (units === 'hour' ? 3600000 : 60000);

        if (memoryDumpState && memoryDumpState.timer) {
            clearInterval(memoryDumpState.timer);
        }

        memoryDumpState = {
            requested: dumpsNumber,
            left: dumpsNumber,
            interval: intervalRequested,
            units: units,
            intervalMs: interval,
            lastDump: Date.now()
        };

        // trigger first dump
        periodicDump();
        // schedule next dump
        memoryDumpState.timer = setInterval(periodicDump, interval).unref();
    }

    if (memoryDumpState) {
        req.memoryDumpState = memoryDumpState;
        memoryDumpState.nextDump = memoryDumpState.lastDump + memoryDumpState.intervalMs - Date.now();
    }

    function periodicDump() {
        memoryDumpState.left--;
        if (memoryDumpState.left <= 0) {
            clearInterval(memoryDumpState.timer);
            memoryDumpState.timer = undefined;
        }
        var ts = Date.now();
        var fileName = util.format('heapdump-%s-%s.heapsnapshot', ts, workerId);
        var heapdumpPath = base + '/' + fileName;
        var snapshot = profiler.takeSnapshot();
        snapshot.export()
            .pipe(fs.createWriteStream(heapdumpPath))
            .on('finish', function () {
                snapshot.delete();
            });
        memoryDumpState.lastDump = ts;
    }
}

function handleCpuProfileRequest(req, res) {
    var duration = req.query.duration;
    if (!req.query.file && duration && duration <=120 && duration >0) {
        if (cpuProfileInProgress) {
            res.status(403).send('CPU profiling is in progress');
            // signal we already handled response
            return false;
        }
        cpuProfileInProgress = true;
        var workerId = ViUtils.getWorkerId();

        var fileName = util.format('cpu-profile-%s-%s.cpuprofile', Date.now(), workerId);
        var base = process.cwd() + '/logs';
        if (!fs.existsSync(base)) {
            fs.mkdirSync(base);
        }
        var cpudumpPath = base + '/' + fileName;

        setTimeout(function delayStart() {
            profiler.startProfiling('CPU Profile', true);
            setTimeout(function completeRecording(){
                cpuProfileInProgress = false;
                var profile = profiler.stopProfiling();
                profile.export().pipe(fs.createWriteStream(cpudumpPath))
                .on('finish', function() {
                    profile.delete();
                });
            }, duration * 1000); //Convert to millisec
        }, 500);

        req.query.file = fileName;
    }
    else {
        req.query.view = 'true';
    }

    return true;
}

// Returns true if IP is internal and update is allowed, else false.
function allowUpdate(req, res) {
    var ip = utils.getRemoteAddr(req);
    var chk = hostipChecker.checkIpSync(ip);
    if (chk.isInternal && chk.hasUpdate && !utils.isIPFromAkamaiHeader(req)) {
        return true;
    }
    return false;
}

function proxyIfRequested(req, res) {
    // if it is not viewing of the results, i.e. file is missing
    // then check if worker id matches the current one
    // if not, then proxy into correct worker via localhost:900{worker number}
    const workerId = ViUtils.getWorkerId();
    if (req.query.worker !== undefined &&
    (req.query.worker !== workerId && parseInt(req.query.worker) !== workerId)) {
        const currentPort = ViUtils.getPort(req);
        const targetPort = ViUtils.getWorkerPort(req.query.worker);
        if (currentPort === targetPort) {
            return false;
        }
        const proxy = Prxy.create({
            hostname: 'localhost',
            port: targetPort,
            protocol: 'http:',
            path: '/admin',
            socketTimeout: 5000,
            connectTimeout: 300
        });
        // proxy now
        proxy(req, res);
        return true;
    }
    return false;
}
