'use strict';

var XPath = require('./xpath');
var _ = require('underscore'),
    os = require('os'),
    ip = require('ip'),
    util = require('util'),
    Async = require('async'),
    path = require('path'),
    fs = require('graceful-fs'),
    moment = require('moment'),
    componentStatus = require('./component-status.js'),
    env = require('environment-ebay'),
    appContext = require('app-context-ebay'),
    configBean = require('config-bean-ebay'),
    Httpunch = require('httpunch'),
    ViUtils = require('./utils'),

    commonModel = function commonModel(forceXml, clientIpAddress) {
        var prod = env.isProd() || env.isPreProd() || env.isSandbox();
        //the following info will be needed by almost all pages of vi
        return {
            'host': os.hostname(),
            'ipAddress': ip.address() || '127.0.0.1',
            'cal': util.format('http://appmon.vip.%sebay.com/logviewui/environment/%s/pool/%s/machine/%s/machineOverview',
                prod ? '' : 'qa.',
                prod ? 'prod' : 'core_stagingsql',
                appContext.poolName,
                machine),
            'clientIpAddress': clientIpAddress || ip.address(),
            'forceXml': forceXml
        };
    };
const machine = /.+\.ebay\.com/.test(appContext.machineName) ? appContext.machineName : ip.address();

const Labels = {
    CPU_USAGE: 'CPU Usage',
    NODE_MEM_USED: 'Node.js Memory Used',
    NODE_MEM_AVAILABLE: 'Node.js Memory Available',
    NODE_MAX_MEM_AVAILABLE: 'Node.js Memory Limits Available',
    NODE_MEM_TOTAL: 'Node.js Memory Total',
    NODE_MAX_MEM_TOTAL: 'Node.js Memory Limits Total',
    ENV_PROPERTIES: 'Environment Properties',
    INIT_STATUS: 'Initialization Status',
    PHYSICAL_MEM_AVAILABLE: 'Physical Memory Available',
    PHYSICAL_MEM_TOTAL: 'Physical Memory Total',
    PID: 'Pid',
    WORKER: 'Worker',
    WORKERS: 'Workers'
};

module.exports.buildServiceComponentsTree = function buildServiceComponentsTree(statusQuery) {
    var beanList = configBean.getConfigBeanList();

    return beanList.reduce((components, component) => {
        const bean = {
            'name': component,
            'link': '/admin/v3console/ViewConfigCategory?id=' + component
        };

        const theBean = configBean.getBeanById(bean.name);

        const svcStatus = theBean.get('SVC_CHANNEL_STATUS');
        if (svcStatus === undefined) {
            return components;
        }

        const index = _.indexOf(['INITIAL_MARK_DOWN',
            'MARK_UP',
            'OPS_MARK_DOWN',
            'OPS_EXTERNAL_PERSIS_MARK_DOWN',
            'APP_AUTO_MARK_DOWN',
            'MARK_DOWN'
        ], svcStatus);

        const view = {
            status: svcStatus + '[' + index + ']',
            markdownStartTime: svcStatus !== 'MARK_UP' ?
                new Date(theBean.lastUpdated('SVC_CHANNEL_STATUS')).toString() : '',
            markdownReason: theBean.get('MARK_DOWN_REASON') ||
                svcStatus !== 'MARK_UP' ? svcStatus : '',
            name: bean.name
        };

        // filer out only components that represent service by using SVC_CHANNEL_STATUS field as an indication of this
        if (view.status && (!statusQuery ||
            view.status.indexOf(statusQuery) !== -1)) {

            components.push(view);
        }

        return components;
    }, []);
};

// Renderers for VI routes
module.exports.renderServiceComponentsTree = function renderServiceComponentsTree(req, res) {

    try {
        var statusQuery = /^UP$|^DOWN$/.test(req.query.Status) ? '_' + req.query.Status : req.query.Status || '';

        const components = module.exports.buildServiceComponentsTree(statusQuery);

        var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
            components: components
        });

        renderXmlResult('service-client-status', model, req, res);
    } catch (err) {
        console.log(err.stack);
    }

};

function getAttributes(componentStatus, mappings) {
    return componentStatus.properties.reduce((memo, prop) => {
        memo[mappings && mappings[prop.name] || prop.name] = prop.value;
        return memo;
    }, {});
}

module.exports.buildTroubleshootingModel = function buildTroubleshootingModel(callback) {
    const modifiedBeans = configBean.getConfigBeans ? configBean.getConfigBeans(true) : [];
    const modifiedAttributes = modifiedBeans.reduce((memo, bean) => {
        const modifiedAttrs = bean.getAttributes(true);
        modifiedAttrs.forEach(attr => {
            memo.push({
                id: bean.configbean.id,
                name: attr.name,
                lastUpdated: attr.lastUpdated,
                oldValue: attr.defaultValue,
                newValue: attr.value
            });
        });
        return memo;
    }, []);

    const hostInfoStatus = getAttributes(
        componentStatus.getStatus('Host Information'));

    let hostInfo = Object.assign(hostInfoStatus, {
        workers: hostInfoStatus.Workers,
        worker: hostInfoStatus.Worker
    });

    const workersInfo = [];
    collectWorkerInfo((err, wksHostInfo) => {
        if (wksHostInfo.length > 1) {
            // calculate avg values out of worker data
            const aggInfo = wksHostInfo.reduce((memo, winfo) => {
                winfo = getAttributes(winfo);

                // collect re-mapped workers info
                workersInfo.push(winfo);

                memo[Labels.CPU_USAGE] = memo[Labels.CPU_USAGE] || 0;
                memo[Labels.CPU_USAGE] += winfo[Labels.CPU_USAGE];

                memo[Labels.NODE_MEM_USED] = memo[Labels.NODE_MEM_USED] || 0;
                memo[Labels.NODE_MEM_USED] += winfo[Labels.NODE_MEM_USED];

                memo[Labels.NODE_MEM_AVAILABLE] = memo[Labels.NODE_MEM_AVAILABLE] || 0;
                memo[Labels.NODE_MEM_AVAILABLE] += winfo[Labels.NODE_MEM_AVAILABLE];

                memo[Labels.NODE_MAX_MEM_AVAILABLE] = memo[Labels.NODE_MAX_MEM_AVAILABLE] || 0;
                memo[Labels.NODE_MAX_MEM_AVAILABLE] += winfo[Labels.NODE_MAX_MEM_AVAILABLE];

                memo[Labels.NODE_MEM_TOTAL] = memo[Labels.NODE_MEM_TOTAL] || 0;
                memo[Labels.NODE_MEM_TOTAL] += winfo[Labels.NODE_MEM_TOTAL];

                memo[Labels.NODE_MAX_MEM_TOTAL] = memo[Labels.NODE_MAX_MEM_TOTAL] || 0;
                memo[Labels.NODE_MAX_MEM_TOTAL] += winfo[Labels.NODE_MAX_MEM_TOTAL];

                return memo;
            }, {});


            hostInfo[Labels.CPU_USAGE] =
                ViUtils.round(aggInfo[Labels.CPU_USAGE]/wksHostInfo.length, 2);
            hostInfo[Labels.NODE_MEM_USED] =
                Math.round(aggInfo[Labels.NODE_MEM_USED]/wksHostInfo.length);
            hostInfo[Labels.NODE_MEM_AVAILABLE] =
                Math.round(aggInfo[Labels.NODE_MEM_AVAILABLE]/wksHostInfo.length);
            hostInfo[Labels.NODE_MAX_MEM_AVAILABLE] =
                Math.round(aggInfo[Labels.NODE_MAX_MEM_AVAILABLE]/wksHostInfo.length);
            hostInfo[Labels.NODE_MEM_TOTAL] =
                Math.round(aggInfo[Labels.NODE_MEM_TOTAL]/wksHostInfo.length);
            hostInfo[Labels.NODE_MAX_MEM_TOTAL] =
                Math.round(aggInfo[Labels.NODE_MAX_MEM_TOTAL]/wksHostInfo.length);
        }

        const appBuildInfo = getAttributes(componentStatus.getStatus('Application Build Information'));

        const baseModel = commonModel();
        const currentTime = new Date();
        const fromDate = moment().format('YYYY-MM-DD+hh:mm');
        const toDate = moment().add(1, 'hours').format('YYYY-MM-DD+hh:mm');

        const srePerfTrends =  `http://sre.vip.ebay.com/ex/c/perfmontrend?trendType=perfmon&poolName=${appContext.poolName}&fromDate=${fromDate}&toDate=${toDate}&dtOverride=&tsd=on`;

        const quickLinks = {
            calLogs: baseModel.cal,
            fileLogs: '/admin/v3console/logs',
            environment: '/admin/v3console/ValidateInternals?component=Environment%20Properties',
            srePerfTrends: srePerfTrends
        };

        const heapDumpLinks = [];
        const cpuProfileLinks = [];
        for (var i = 0; i < ViUtils.getWorkersNumber(); i++) {
            heapDumpLinks.push(`<a href="profile?type=memory&worker=${i}">worker ${i}</a>`);
            cpuProfileLinks.push(`<a href="profile?type=cpu&duration=30&worker=${i}">worker ${i}</a>`);
        }

        const quickActions = {
            disableLogging: 'Disable "debug" logging for this machine <a href="">Not Yet Available</a>',
            enableLogging: 'Enable "debug" logging for this machine <a href="">Not Yet Available</a>',
            heapDump: `Performs a Heap Dump. View heapdump <a>here</a> or generate heapdump (Do Heap Dump  for ${heapDumpLinks.join(', ')})`,
            cpuProfile: `Performs quick CPU profiling (30 seconds) of the specific worker (Profile ${cpuProfileLinks.join(', ')})`
        };

        // let's generate service status table
        const serviceMetrics = componentStatus.getComponents().reduce((memo, name) => {
            if (/^(SOA|REST)\./.test(name)) {
                memo.push(componentStatus.getStatus(name));
            }
            return memo;
        }, []);

        const serviceStatus = module.exports.buildServiceComponentsTree();

        callback(null, {
            modifiedAttributes: modifiedAttributes,
            hostInfo: hostInfo,
            appBuildInfo: appBuildInfo,
            quickLinks: quickLinks,
            quickActions: quickActions,
            serviceMetrics: serviceMetrics,
            serviceStatus: serviceStatus,
            workersHostInfo: workersInfo,
            ViUtils: ViUtils
        });
    });

};

function createSafeFunction(fn) {
    return function safe() {
        try {
            return fn.apply(null, arguments);
        } catch (err) {
            console.log(err.stack);
        }
    };
}

module.exports.renderTroubleshooting = function renderServiceComponentsTree(req, res) {
    createSafeFunction(() => module.exports.buildTroubleshootingModel(createSafeFunction((err, model) => {
        model = _.extend(
            commonModel(req.query.forceXml, req.query.ip),
            model);

        renderXmlResult('troubleshooting', model, req, res);
    })))();
};

module.exports.renderConfigCategoryList = function renderConfigCategoryList(req, res) {

    var group = configBean.getConfigBeansGrouped();
    var groups = Object.keys(group).sort(); // Put the keys in order
    var configCategoryGroups = [];
    groups.forEach(function (gElt) {
        var groupElt = group[gElt];
        var categories = groupElt.map(function (name) {
            return {
                id: name
            };
        });
        var catElt = {
            name: gElt,
            configCategorys: categories
        };
        configCategoryGroups.push(catElt);
    });
    render(configCategoryGroups);

    function render(configCategoryGroups) {
        try {
            var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
                configCategoryGroups: configCategoryGroups
            });

            renderXmlResult('config-category-list', model, req, res);
        } catch (err) {
            console.log(err.stack);
        }
    }
};

module.exports.renderComponentStatusList = function renderComponentStatusList(req, res) {

    var componentList = componentStatus.getComponents();
    var components = componentList.map(function (elt) {
        return {
            name: elt,
            link: '/admin/v3console/ValidateInternals?component=' + elt
        };
    });

    var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
        components: components
    });

    renderXmlResult('component-status-list', model, req, res);
};

module.exports.generateEnvironmentProperties = function generateEnvironmentProperties() {
    return {
        name: Labels.ENV_PROPERTIES,
        alias: Labels.ENV_PROPERTIES,
        properties: Object.keys(process.env).reduce((memo, key) => {
            memo.push({
                name: key,
                value: process.env[key]
            });
            return memo;
        }, [])
    };
};

module.exports.renderEnvironmentProperties = function renderEnvironmentProperties(req, res) {
    var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
        component: module.exports.generateEnvironmentProperties()
    });

    renderXmlResult('component-status', model, req, res);
};

module.exports.renderConfigBean = function renderConfigBean(req, res) {

    var query = req.query,
        id = query.id,
        view = query.forceXml;

    var theBean = configBean.getBeanById(id);
    var bean = theBean ? theBean.configbean : theBean;

    if (!bean) {
        res.status(404).send('no such configbean');
    } else {
        // Convert any array-valued attributes to string form for display/edit
        var attribs = theBean.getAttributes();
        for (var i = 0; i < attribs.length; i++) {
            if (Array.isArray(attribs[i].value)) {
                attribs[i].value = JSON.stringify(attribs[i].value);
            }
            if (Array.isArray(attribs[i].defaultValue)) {
                attribs[i].defaultValue = JSON.stringify(attribs[i].defaultValue);
            }
        }
        var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
            'time': moment(Date.now() - process.uptime()).format('ddd MMMM DD HH:mm:ss Z YYYY'),
            'id': id,
            'alias': bean.alias,
            'group': bean.group,
            'desc': bean.desc,
            'attributes': attribs
        });
        renderXmlResult('config-category', model, req, res);
    }
};

module.exports.renderComponentStatus = function renderComponentStatus(req, res) {
    var component = req.query.component;
    var value = req.query.value;
    var status = componentStatus.getStatus(component);
    var renderer = componentStatus.getRenderer(component);
    var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
        component: status
    });

    if (!renderer) {
        renderXmlResult('component-status', model, req, res);
    } else {
        return renderer(req, model, res);
    }
};

function collectWorkerInfo(callback) {
    if (ViUtils.getWorkersNumber() <= 1) {
        return callback(null, []);
    }
    // collect metrics (cpu, memory) for all workers
    Async.times(ViUtils.getWorkersNumber(), (workerId, next) => {
        Httpunch.get(`http://localhost:${ViUtils.getWorkerPort(workerId)}/admin/v3console/ValidateInternals?component=Host%20Information&json=true&worker=${workerId}`,
        (err, res) => {
            if (err || res.statusCode >= 300 ||
                !/^application\/json/.test(ViUtils.getHeader(res, 'Content-Type'))) {
                return next();
            }

            let info = ViUtils.tryParse(res.body.toString());
            if (!info) {
                return next();
            }

            const metas = info.components.filter(meta => {
                return meta.name === 'Host Information';
            });

            info = metas[0];

            var workerInfo = {
                name: `${info.name} Worker ${workerId}`,
                alias: `${info.alias} Worker ${workerId}`,
                status: info.status,
                properties: info.properties.filter(prop => {
                    return [
                        Labels.CPU_USAGE,
                        Labels.INIT_STATUS,
                        Labels.NODE_MEM_USED,
                        Labels.NODE_MAX_MEM_AVAILABLE,
                        Labels.NODE_MEM_AVAILABLE,
                        Labels.NODE_MAX_MEM_TOTAL,
                        Labels.NODE_MEM_TOTAL,
                        Labels.PHYSICAL_MEM_AVAILABLE,
                        Labels.PHYSICAL_MEM_TOTAL,
                        Labels.PID,
                        Labels.WORKER
                    ].indexOf(prop.name) !== -1;
                })
            };

            next(null, workerInfo);
        });
    }, (err, workersInfo) => {
        if (err) {
            callback();
            return;
        }

        callback(null, workersInfo.filter(info => {
            return info !== undefined;
        }));
    });
}
module.exports.collectWorkerInfo = collectWorkerInfo;

module.exports.renderDefaultComponentStatus = function renderDefaultComponentStatus(req, res) {

    if (ViUtils.getWorkersNumber() > 1 && req.query.worker === undefined) {
        // collect metrics (cpu, memory) for all workers
        collectWorkerInfo((err, infos) => {
            doRender(infos);
        });

        return;
    }

    function doRender(workerHostInfo) {
        var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
            'components': [
                componentStatus.getStatus('Host Information'),
                componentStatus.getStatus('Initialization Information'),
                componentStatus.getStatus('Application Build Information')
            ]
        });

        if (workerHostInfo) {
            model.components = model.components.concat(workerHostInfo);
        }

        if (req.query.json === 'true') {
            res.json(model);
            return;
        }

        renderXmlResult('validate-internals', model, req, res);
    }

    doRender();
};

function renderXmlResult(templateName, model, req, res) {
    if (req.query.xpath) {
        res.type('xml').render(templateName, model, function (err, content) {
            if (err) {
                res.status(500).end('<error>' +
                    err.stack +
                    '</error>');
                return;
            }
            res.send(XPath.select(content, req.query.xpath));
        });
        return;
    }
    return res.type('xml').render(templateName, model);
}

module.exports.threadResourceRender = function threadResourceRender(req, renderData, res) {
    var datetime = moment(Date.now()).format('YYYY/MM/DD%20HH:mm');

    // var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
    var model = renderData;
    model.pool = appContext.poolName;
    model.machine = appContext.machineName;
    model.datetime = datetime;
    if (res) {
        renderXmlResult('threads-resource-consumption', model, req, res);
        return;
    } else {
        var ejs = require('ejs');
        ejs.open = '|';
        ejs.close = '~';

        var tmpl = path.resolve(__dirname, 'public/views/threads-resource-consumption.ejs');
        var tpl = fs.readFileSync(tmpl).toString('utf8');

        var result = ejs.render(tpl, model);
        // Restore the EJS default open/close
        ejs.open = '<%';
        ejs.close = '%>';

        return result;
    }


};

module.exports.renderProfilePage = function renderProfilePage(req, res) {
    var base = process.cwd();
    var logsPath = path.resolve(base, 'logs');
    var model = _.extend(commonModel(req.query.forceXml, req.query.ip), {
        type: req.query.type,
        file: req.query.file || '',
        duration: req.query.duration || '',
        view: req.query.view || 'false',
        base: base,
        workersNumber: ViUtils.getWorkersNumber(),
        worker: ViUtils.getWorkerId()
    });

    switch(req.query.type) {
        case 'cpu':
            model.status = getProfiles(function filter(name) {
                return /^cpu-profile-/.test(name);
            }, /^cpu-profile-(\d+)-\d+\.cpuprofile/, function (err, profiles) {
                // extract timestamp
                if (!err) {
                    model.profiles = profiles;
                }
                render();
            });
            break;
        case 'memory':
            model.status = req.memoryDumpState;
            getProfiles(function filter(name) {
                return /^heapdump-\d+-\d+.heapsnapshot/.test(name);
            }, /^heapdump-(\d+)-\d+.heapsnapshot/, function (err, profiles) {
                // extract timestamp
                if (!err) {
                    model.profiles = profiles;
                }
                render();
            });
            break;
    }


    function getProfiles(filter, pattern, callback) {
        fs.readdir(logsPath, function handleFiles(err, files) {
            if (err) {
                // ignore error
                return callback();
            }
            var profiles = files.reduce(function reduce(memo, fileName) {
                if (filter(fileName)) {
                    var matched = fileName.match(pattern);
                    if (matched) {
                        memo.push({
                            ts: parseInt(matched[1], 10),
                            date: moment(new Date(parseInt(matched[1], 10))).format('MM-DD-YY.HH:mm:ss'),
                            file: fileName,
                            size: fs.statSync(path.join(logsPath, fileName)).size
                        });
                    }
                }
                return memo;
            }, []).sort(function (a, b) {
                return b.ts - a.ts;
            });
            callback(null, profiles);
        });
    }

    function render() {
        renderXmlResult('profile-view', model, req, res);
    }

};
