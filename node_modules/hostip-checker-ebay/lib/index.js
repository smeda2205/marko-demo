'use strict';

var modConfigLoader = require('module-config-inc'),
    debug = require('debug')('hostip-checker-ebay'),
    logger = require('logging-inc').logger('hostipchecker/index'),
    evironment = require('environment-ebay'),
    authService = require('./services'),
    ipUtil = require('ip'),
    net = require('net'),
    cs = require('./constants'),
    dns = require('dns'),
    fs = require('fs'),
    path = require('path'),
    async = require('async'),
    tryRequire = require('try-require'),
    hostipchecker,
    parser = require('./configurator');

var Qualyscan = require('./qualyscan');

var ipAuthCache = parser.parse(require('../config/eBayNetworks.json')),
    coldCacheFilename = path.join(__dirname, '../config/eBayNetworks.json'),
    cachedTimestamp = Date.now(),
    cacheTimeout = 24*60*60*1000;


/**
 * Exports
 */
exports = module.exports = {
    isQualyscanIP: Qualyscan.isQualyscanIP,
    checkIp : checkIp,
    checkIpSync: checkIpSync,
    checkHost : checkHost,
    reset : reset,
    setCacheTimeout : function(newTimeout) {
        cacheTimeout = newTimeout;
    }
};

/**
 *
 * @constructor
 */
function IPChecker (networks){
	this._networks = networks;
}

IPChecker.prototype = {
	/**
	 * Get the meta of the ip (isInternal, hasUpdate etc).
	 * @param ip
	 * @param cb
	 * @public
	 */
	ipMeta : function (ip, cb) {

    // handling IPv4-mapped IPv6 addresses - http://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses
    if (/^::ffff:(\d{1,3}\.){3,3}\d{1,3}$/.test(ip)) {
      ip = ip.replace(/^::ffff:/, '');
    }

		debug("ipMeta: isInternal?, hasUpdate? : " + ip);
		var self = this,
			isIPv6 = net.isIPv6(ip),
			family = isIPv6 ? cs.IPV6_KEY: cs.IPV4_KEY,
			networks = self._networks && self._networks[family],
			hasUpdate = false,
			//If the Network Config is missing consider all the IP as external.
			isInternal = false,
			error;
		var hasAccessRole = function hasRole(roleName) {
			if(!networks){
				return false;
			}
		try {

		    return Object.keys(networks).some(function (networkName) {
          var network = networks[networkName],
		            subnet = network[cs.SUBNET_KEY],
		            masks = network[cs.MASK_KEY],
		            access = network[cs.ACCESS_KEY],
		            mask;
		        debug('ip : ' + ip);
		        debug("subnet : " + subnet);
		        debug("masks : " + masks);
		        debug("access : " + access);
		        //Skip, if subnet or mask skip is found empty.
		        if (!subnet || !masks || masks.length === 0) {
		            return false;
		        }
		        subnet = isIPv6 ? subnet : parseInt(subnet.toUpperCase(), 16); //Hex decimal to Number

		        //Compare the ip against subnet and each mask
		        return masks.some(function (maskName) {
		            if (!maskName) {
		                return false;
		            }
		            /**
		             * Perform a bitwise operation on ip and masks.
		             * If the result matches the Subnet, then its an internal IP.
		             */
		            mask = isIPv6 ? maskName : parseInt(maskName, 16); //Hex decimal to Number
		            debug("mask : " + mask);
		            if (access === roleName && _ipComparator(ip, subnet, mask)) {
		                return true;
		            }
		            return false;
		        });
		    });

		} catch (err) {
		    debug("ERROR : " + err);
		    error = err;
		}
	};


	var canUpdate = hasAccessRole('update');

	var resp = {
	    isInternal: canUpdate ? true : hasAccessRole('view'),
	    hasUpdate: canUpdate
	};

		if (cb) {
			return cb(error, resp);
		} else {
			return resp;
		}

	}
};

/**
 * Compare IP with the subnet using the mask/prefix value.
 * @return boolean
 */
function _ipComparator (ip, subnet, mask) {
	debug("_ipComparator: " + ip + "   subnet - " + subnet + "  mask - " + mask);
	var isIPv6 = net.isIPv6(ip);
	//IPv6
	if (isIPv6) {
		return _isIpEqual(_masker(ip, mask), _masker(subnet, mask));
	} else {
	//IPv4
		return (subnet === (ipUtil.toLong(ip) & mask));
	}
}

/**
 * The mask for IPv6 is determined from the prefix.
 * Prefix refers to the number of bits considred for calculating the network address mask in the IP.
 * @param ip - String
 * @param prefix - number
 * @return maskedAddr - Buffer - Masked Address.
 */
function _masker(ip, prefix) {
	debug("_masker : ip  - " + ip + "  prefix - " + prefix);
	var prefixBlock = prefix / cs.BYTE_LENGTH,
		remainBits = prefix % cs.BYTE_LENGTH,
		ipBuffer = ipUtil.toBuffer(ip),
		maskedAddr;

	if(remainBits > 0) {
		prefixBlock = prefixBlock + 1;
	}
	// Use the number prefix block to mask the IP Buffer
	maskedAddr = ipBuffer.slice(0, prefixBlock);
	debug("prefixBlock - " + prefixBlock);
	debug("remainBits - " + remainBits);

	if(remainBits > 0) {
		var mask = ( 0xFFFF << (cs.BYTE_LENGTH - remainBits)) & 0x00FF;
		maskedAddr[prefixBlock - 1] = maskedAddr[prefixBlock - 1] & mask;
	}
	return maskedAddr;
}

/**
 * Equal check for same IP protocols. Input can be a buffer or string format
 * @param ip1 Buffer/String
 * @param ip2 Buffer/String
 * @private
 */
function _isIpEqual(ip1, ip2) {
	ip1 = (Buffer.isBuffer(ip1)) ? ip1 : ipUtil.toBuffer(ip1);
	ip2 = (Buffer.isBuffer(ip2)) ? ip2 : ipUtil.toBuffer(ip2);

	// Same protocol
	if (ip1.length === ip2.length) {
		for (var i = 0; i < ip1.length; i++) {
			if (ip1[i] !== ip2[i]) {
				return false;
			}
		}
		return true;
	}
	return false;
}

//Sync Version
function checkIpSync(ip) {

	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};
	if (net.isIP(ip) === 0) {
		//Return false for Invalid IP.
		return resp;
	}
    resp = hostipchecker.ipMeta(ip);
    refreshCache();
    return resp;
}

//Asyn version
function checkIp(ip, cb) {
	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};

	if (net.isIP(ip) === 0) {
		return cb(new Error("Invalid IP " + ip), resp);
	}

	hostipchecker.ipMeta(ip, cb);
    refreshCache();
}


function checkHost(host, cb) {

	var resp = {
		isInternal	: false,
		hasUpdate	: false
	};
	async.waterfall([
		function(callback){
			dns.resolve6(host, function (err, addresses) {
				if (err || !addresses || addresses.length === 0) {
					//Might be IPv4
					callback(null, addresses);
				} else {
					//IPv6. passing error only to skip the IPv4 check.
					callback(new Error("Found Ipv6"), addresses);
				}
			});
		},
		function(addresses, callback){
			dns.resolve4(host, function (err, addresses) {
				callback(err, addresses);
			});
		}
	], function (err, addresses) {

		if (!addresses || addresses.length === 0) {
			//Return the Default Response in case we could not find an address for the Host.
			cb && cb(null, resp);
		} else {
			//Check only one of the addresses: If one address is private/public the host is private/public.
			var address = addresses[0];
			checkIp (address, function(err, resp){
				cb && cb(err, resp);
			});
		}
	});
}

function refreshCache(callback) {
    if(Date.now() > (cachedTimestamp + cacheTimeout)) {
        logger.info('Cache Expired, fetching latest IP list');
        var tempCachedTimestamp = cachedTimestamp;
        cachedTimestamp = Date.now();
        authService.loadAuthIP(function(error, response){
            if(error) {
                //if service errors out retry after 5 mins, advance timestamp to 5 mins
                cachedTimestamp = tempCachedTimestamp + (5*60*1000);
            } else {
                createColdCache(JSON.stringify(response), coldCacheFilename);
                //Parse the JSON Object loaded from Cold Cache or from service
                ipAuthCache = parser.parse(response);
                reset();
            }
        });
  }
}

function createColdCache(content, fileName) {
  var tempFileName = fileName + Math.floor(Math.random()*10000);
      fs.writeFile(tempFileName, content, function(writeError){
        if(!writeError) {
          fs.rename(tempFileName, fileName, function(renameError){
            if(renameError) {
              logger.error('Error Renaming Temp Cold cache file', renameError);
            }
          });
        } else {
          logger.error('Error Writing Temp Cold cache file', writeError);
        }
      });

}

function reset() {
  var env = process.env.NODE_ENV || 'production';
  if(evironment.isProd()) {
      env = 'production';
  }
  var authCacheEntry = ipAuthCache[env] || ipAuthCache.production;
  hostipchecker = new IPChecker(authCacheEntry[cs.NETWORKS_KEY]);
  return true;
}

reset();
