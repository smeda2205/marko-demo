'use strict';
var path = require('path'),
	fs = require('fs'),
	cs = require('./constants'),

	propUtil = require('properties');

module.exports = exports = {
	parse : parse
};

/**
 * The configurator gets invoked at Build time (not deploy or run time), so we dont have the info
 * on the current ENV. This is defined to parse the legacy properties file keys to the kraken/confit/module-config
 * format of defining config files.
 */
var envList = {
	dev				: "development",
	production		: "production",
	sandbox			: "sandbox",
	staging			: "staging",
	feature			: "qa",
	preproduction	: "pre-production"
}, fileSystemCache = path.join(__dirname, '../config/eBayNetworks.json'), configList = {};

/**
 * Parse the properties file to generate the JSON config files.
 */
function parse (data) {
	/**
	 * Map the list to build the absolute path of the config files
	 */
	configList = mapper(envList);

	//Get the IPv4 Network List.
	parseNetworks(data, cs.IPV4_KEY);

	//Get the IPv6 Network List.
	parseNetworks(data, cs.IPV6_KEY);

	for(var env in envList){
		if(envList[env] !== env) {
			configList[envList[env]] = configList[env];
			delete configList[env];
		}
	}

	configList.test = configList.staging;
	configList.lnp = configList.staging;

	return configList;

}

function parseNetworks(obj, family) {

	var masks = Object.create(null),
		networkNames,
		networkKey,
		maskKey,
		accessKey,
		masksArray,
		configObj,
		network,
		networkObj;

	networkNames = isIPv4Family(family) ? obj[cs.IPV4_NETWORK_LIST] : obj[cs.IPV6_NETWORK_LIST];
	if (networkNames) {
		networkNames.split(";").forEach(function(network){
			network = network.trim();
			masksArray = [];
			/**
			 * The key to access the network name
			 * Format - ebay.network.EBAYNet1=D8207800
			 */
			networkKey = cs.NETWORK_PREFIX + "." + network;
			/**
			 * The key to access the mask value
			 * Format - ebay.network.EBAYNet1.masks=mask24
			 */
			maskKey = networkKey + "." + cs.MASK_KEY;
			if (obj[maskKey]) {
				//var masksArray = [];
				// var masksArr = obj[maskKey].split(";");
				// for (var maskkey in masksArr) {
				// 	masksArray.push(obj[cs.MASK_PREFIX + "." + masksArr[maskkey]]);
				// }
				masksArray = obj[maskKey].split(";").map(function(maskkey){
					return obj[cs.MASK_PREFIX + "." + maskkey];
				});
			}
			/**
			 * Update this to network JSON
			 * "EBAYNet1" : {
			 *	"subnet"	: "D8207800",
			 *	"masks"		: ["ff000000"],
			 *	"access"	: "view"
			 * }
			 */
			Object.keys(configList).forEach(function(env){
				configObj = configList[env][cs.NETWORKS_KEY];
				//Get the config object of the IP Family.
				configObj = configObj[family];
				networkObj = Object.create(null);
				/**
				 * The key to access the mask value
				 * Format - ebay.network.EBAYNet1.production.access=view
				 */
				accessKey = networkKey + "." + env + "." + cs.ACCESS_KEY;
					networkObj[cs.SUBNET_KEY] = obj[networkKey];
					networkObj[cs.MASK_KEY] = masksArray;
				networkObj[cs.ACCESS_KEY] = obj[accessKey];
				configObj[network] = networkObj;
			});
		});
	}
}

function isIPv4Family(family) {
	return ( cs.IPV4_KEY === family);
}


function mapper (envList) {
	var configList = {};
	Object.keys(envList).forEach(function(env){
		var config = {};
		//Initialize with an empty object
		// config.obj = {};
		// config.obj[cs.MODULE_NAME_KEY] = {};
		config[cs.NETWORKS_KEY] = {};
		config[cs.NETWORKS_KEY][cs.IPV4_KEY]= {};
		config[cs.NETWORKS_KEY][cs.IPV6_KEY] = {};
		configList[env] = config;
	});
	return configList;
}
