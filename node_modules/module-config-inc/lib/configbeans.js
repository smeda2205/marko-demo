/*jslint proto: true */
'use strict';

var cache = require('memory-cache'),
    tryRequire = require('try-require'),
    configBean = require('config-bean-ebay'),
    RaptorConfig = require('raptor-config-ebay'),
    EventEmitter = require('events').EventEmitter,
    _ = require('underscore'),
    debug = require('debug')('modconfig:configbeans');

var cal = tryRequire('cal');

function configChangeHeartBeat(type, name, payload) {
    if (cal) {
        var calInfo = cal.createHeartbeat(type, name);
        if (payload) {
            calInfo.addData(payload);
        }
        calInfo.complete();
    }
}

function makeEventEmitter(configObject) {
    configObject.prototype = Object.create(EventEmitter.prototype);
    configObject.__proto__ = EventEmitter.prototype;
}

function onConfigBeanChange(cacheKey, bean, emitEvent, mappings) {
    var hasChanged = false,
        index,
        prop,
        configObjectKey,
        configObjectValue,
        beanValue;

    var configObject = cache.get(cacheKey);
    var beanValues = bean.configbean && bean.configbean.attributes;
    if (configObject && beanValues) {
        for (index in beanValues) {
            prop = beanValues[index];
            var name = prop.name;
            configObjectKey = name.replace(/___/g, ':');
            // remap
            configObjectKey = mappings && mappings[configObjectKey] || configObjectKey;
            configObjectValue = configObject.get(configObjectKey);
            beanValue = bean.get(prop.name);
            if (beanValue !== undefined && (configObjectValue === undefined ||
                                            !_.isEqual(configObjectValue, beanValue))) {
                configObject.set(configObjectKey, beanValue);
                hasChanged = true;
            }
        }
    }
    if (hasChanged && emitEvent) {
        configObject.emit('change');
    }
}

/**
 * Creating config bean using @ConfigBean section in config,
 * using moduleName as the name
 */
function createConfigBean(name, config) {
    var beanConfigDef = config && config.get('@ConfigBean'),
        beans = {};

    beanConfigDef = beanConfigDef && beanConfigDef[name];

    if (beanConfigDef) {
        if (Array.isArray(beanConfigDef)) {
            // array of paths to form a single config bean
            var bean = createSingleBean(name, beanConfigDef, name, config);
            beans[name] = bean;
            debug('creating bean: %s', name);
        }
        else if (typeof beanConfigDef === 'object') {
            if (isMappings(beanConfigDef)) {
                beans[name] = createSingleBean(name, Object.keys(beanConfigDef), name, config, beanConfigDef);
                debug('creating bean: %s', name);
            }
            else {
                // this is specific to separate config beans
                Object.keys(beanConfigDef).forEach(function forEach(key) {
                    if (/^@/.test(key)) {
                        return;
                    }
                    var id = [name, key].join('.');
                    var bean;
                    var keyDef = beanConfigDef[key];
                    if (Array.isArray(keyDef)) {
                        bean = createSingleBean(id, keyDef, name, config);
                    }
                    else {
                        var mappings = isMappings(keyDef) ? keyDef : undefined;
                        var def = beanConfigDef[key];
                        bean = createSingleBean(id, Object.keys(def), name, config, mappings);
                    }
                    beans[key] = bean;
                    debug('creating bean: %s', key);
                });
            }
        }
    }

    return beans;
}


function isMappings(obj) {
    // when obj is a bunch of mappings of string to string, then it is a mapping
    if (Array.isArray(obj)) {
        return false;
    }
    for(var key in obj) {
        if (typeof obj[key] === 'object') {
            return false;
        }
    }
    return true;
}

function createSingleBean(id, def, cacheKey, config, mappings) {
    var beanConfig = {},
        prop,
        propVal,
        dotProp;
    for (var index in def) {
        prop = def[index];
        if (prop && prop.indexOf('@') === -1) {
            // Internally map : to . for ValidateInternals
            dotProp = prop;

            dotProp = mappings && mappings[dotProp] || dotProp;
            dotProp = dotProp.replace(/:/g, '___');

            propVal = config.get(prop);
            if (typeof propVal === 'object') {
                if (Object.keys(config.get(prop)) && Object.keys(config.get(prop)).length > 0) {
                    beanConfig[dotProp] = config.get(prop);
                }
            } else if (propVal !== undefined) {
                beanConfig[dotProp] = config.get(prop);
            }
        }
    }

    var bean = configBean.defineConfig(beanConfig, id);
    config.use(bean.getConfig());   //merging memory object with static bean config

    //load updates for configBean immediately
    if (mappings) {
        mappings = _.invert(mappings);
    }
    onConfigBeanChange(cacheKey, bean, false, mappings);
    configChangeHeartBeat('CREATE_CONFIG', id);

    //listen for configBean changes
    bean.on('changed', onConfigBeanChange.bind(bean, cacheKey, bean, true, mappings));

    return bean;
}

/**
 * On raptorConfig change, update the local config bean
 * if bean updates, it will trigger the `changed` event.
 */
function onRaptorConfigChange(keyPath, bean, mappings, message) {
    var props,
        key;

    if (message && message.properties) {
        // Using . separator for ValidateInternals
        keyPath = keyPath ? keyPath + '___' : '';
        for (var index in message.properties) {
            props = message.properties[index];
            if (props) {
                key = keyPath + props.key;
                var mappedKey = mappings && mappings[key.replace(/___/g, ':')];
                key = mappedKey || key;
                key = key.replace(/:/g, '___');
                var val = bean.get(key);

                if (mappedKey || !mappings && !_.isEqual(val, props.value)) {

                    bean.setPersist(key, props.value);
                    configChangeHeartBeat('UPDATE_CONFIG', key, {src: 'raptorConfig', value: props.value});
                }
            }
        }
    }
}

/**
 * Creating raptor config bean using @RaptorConfig section in config,
 * using moduleName as the name
 * 'keyPath' can be used to specify the local key prefix for mapping config.json
 * configs with raptor config.
 */
function registerRaptorConfigs(name, configObject, beans) {
    var raptorConfigDef = configObject && configObject.get('@RaptorConfig');

    raptorConfigDef = raptorConfigDef && raptorConfigDef[name];

    if (raptorConfigDef && beans) {
        for (var index in raptorConfigDef) {
            var prop = raptorConfigDef[index],
                keyPath = null;

            if (prop) {
                if (prop.keyPath) {
                    keyPath = prop.keyPath;
                    delete prop.keyPath;
                }
                var raptorConfig = new RaptorConfig();
                raptorConfig.load(prop);
                configChangeHeartBeat('LISTENING_RAPTOR_CONFIG', name, prop);

                for(var key in beans) {
                    if (prop.mapTo && prop.mapTo !== key) {
                        continue;
                    }
                    var mappings = getMappings(name, key, configObject);
                    raptorConfig.on('read',
                        onRaptorConfigChange.bind(raptorConfig, keyPath, beans[key], mappings));
                    debug('registering raptor config: %s', key);
                }
            }
        }
    }
}

function getMappings(name, beanName, configObject) {
    var configBeanDef = configObject && configObject.get('@ConfigBean') || {};
    configBeanDef = configBeanDef[name] || {};
    if (isMappings(configBeanDef)) {
        return configBeanDef;
    }
    configBeanDef = configBeanDef[beanName] || configBeanDef;
    return isMappings(configBeanDef) ? configBeanDef : undefined;
}

module.exports = {
    makeEventEmitter: makeEventEmitter,
    createConfigBean: createConfigBean,
    registerRaptorConfigs: registerRaptorConfigs
};
