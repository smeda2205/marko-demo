/*jslint proto: true */
'use strict';

var path = require('path'),
    assert = require('assert'),
    fs = require('graceful-fs'),
    cache = require('memory-cache'),
    tryRequire = require('try-require'),
    configbeans = require('./configbeans'),
    confit = require('confit_mod'),
    Handlers = require('shortstop-handlers'),
    commonConfit = require('confit_mod/lib/common'),
    async = require('async'),
    debug = require('debug')('modconfig:utils');

var nconfCheck = false,
    nconf;

var mappings = {};

var CONFIG_TOKEN = '||**||';

function mergeWithNconf(output) {
    var outputTemp;
    if (!nconfCheck) {
        nconf = tryRequire('nconf');
        nconfCheck = true;
    }
    if (nconf && nconf.get()) {
        outputTemp = {};
        // Use nconf values as default, if available
        commonConfit.merge(nconf.get(), outputTemp);
        commonConfit.merge(output, outputTemp);
        output = outputTemp;
    }
    return output;
}

function registerAndCacheConfig(cacheKey, configObject) {
    var beanCacheKey = '__bean__' + cacheKey;
    if (!cache.get(beanCacheKey)) {
        cache.put(beanCacheKey, true);
        var bean = configbeans.createConfigBean(cacheKey, configObject);
        configbeans.registerRaptorConfigs(cacheKey, configObject, bean);
        configbeans.makeEventEmitter(configObject);
    }
    cache.put(cacheKey, configObject);

    return configObject;
}

function getDefaultConfig(moduleConfigRoot, callback) {
    var env = (process.env.NODE_ENV || 'development').toLowerCase();
    debug('env: ' + env);

    debug('confiter module basedir (defaults) :', moduleConfigRoot);

    var confiter = confit({
        basedir: moduleConfigRoot,
        protocols: {
            path: Handlers.path(moduleConfigRoot)
        }
    });

    var mConf = path.resolve(moduleConfigRoot, env + '.json');
    if (fs.existsSync(mConf)) {
        debug('addDefault config :', mConf);
        confiter.addOverride(mConf);
    }

    confiter.create(callback);
}

function _findModuleRoot(fpath) {
    var appRoot = process.cwd(),
        _fpath;

    var pkgPath = path.resolve(fpath, 'package.json');
    if (fs.existsSync(pkgPath)) {
        debug('_findModuleRoot ' + fpath);
        return fpath;
    }
    _fpath = path.dirname(fpath);
    if (_fpath === fpath || _fpath === '/' || _fpath === appRoot) {
        debug('_findModuleRoot for ' + fpath + ' : ' + appRoot);
        return appRoot;
    }
    fpath = _fpath;

    return _findModuleRoot(fpath);
}

function moduleRoot(moduleRef) {
    var fpath = moduleRef.filename || moduleRef;
    return mappings[fpath] = mappings[fpath] ||
        _findModuleRoot(fpath);
}

function getPackage(modRoot) {
    assert.ok(modRoot, 'Module root is not found: ' + modRoot);
    var pkg = cache.get(modRoot);
    if (!pkg) {
        var pkgLocation = path.resolve(modRoot, 'package.json');
        pkg = tryRequire(pkgLocation);
        if (pkg) {
            cache.put(modRoot, pkg);
        }
    }
    return pkg;
}

function moduleName(modRoot) {
    var pkg = getPackage(modRoot);
    return pkg && pkg.name || modRoot.split(path.sep).pop();
}

function generateCacheKey(modRoot) {
    var pkg = getPackage(modRoot);
    return pkg && pkg.name || modRoot.split(path.sep).pop();
    // return pkg && pkg.name ? (pkg.name + '@' + pkg.version) : modRoot.split(path.sep).pop();
}

function loadModuleConfig(options, callback) {
    var moduleConfigRoot = options.moduleConfigRoot;
    var appConfigRoot = options.appConfigRoot;
    var modRoot = options.modRoot;
    var asyncMode = options.asyncMode;

    var cacheKey;
    if (asyncMode) {
        cacheKey = generateCacheKey(modRoot);
    }
    var configObject = asyncMode && cache.get(cacheKey);

    if (configObject) {
        return callback(null, configObject);
    }

    async.waterfall([
        function loadDefaultConfig(next) {
            if (moduleConfigRoot && appConfigRoot && (appConfigRoot !== moduleConfigRoot)) {
                return getDefaultConfig(moduleConfigRoot, next);
            }
            next(null, null); // no default config needed
        },
        function loadAppConfig(defaultConfig, next) {
            debug('default config:', defaultConfig);
            var confiter = confit({
                basedir: appConfigRoot,
                protocols: {
                    path: Handlers.path(appConfigRoot)
                }
            });

            debug('confiter app basedir : ' + appConfigRoot);

            confiter.create(function (err, configObject) {
                if (err) {
                    return next(err);
                }
                if (!asyncMode) {
                    if (defaultConfig) {
                        configObject._store = commonConfit.merge(configObject._store,
                            commonConfit.merge(defaultConfig._store, {}));
                    }
                    return next(err, configObject);
                }
                // pick up configObject created by other flow
                var otherConfigObject = cacheKey && cache.get(cacheKey);
                if (otherConfigObject) {
                    return next(null, otherConfigObject);
                }

                if (err && !configObject) {
                    console.error(err);
                } else {
                    if (defaultConfig) {
                        configObject._store = commonConfit.merge(configObject._store,
                            commonConfit.merge(defaultConfig._store, {}));
                    }
                    configObject.use(mergeWithNconf(configObject._store || {}));

                    registerAndCacheConfig(cacheKey, configObject);

                }
                next(err, configObject);
            });

        }
    ], callback);
}

module.exports = {
    moduleRoot: moduleRoot,
    generateCacheKey: generateCacheKey,
    moduleName: moduleName,
    getDefaultConfig: getDefaultConfig,
    mergeWithNconf: mergeWithNconf,
    CONFIG_TOKEN: CONFIG_TOKEN,
    registerAndCacheConfig: registerAndCacheConfig,
    loadModuleConfig: loadModuleConfig
};
