'use strict';

var _ = require('underscore');

var ATTRIB_ACCESSOR = 'attributes';

var SOA_HEADERS = require('./soa-headers');
var SUCURE_HEADERS = _.reduce([
    SOA_HEADERS.AUTH_ASSERTION,
    SOA_HEADERS.AUTH_COOKIE,
    SOA_HEADERS.AUTH_TOKEN,
    SOA_HEADERS.AUTH_USERID,
    SOA_HEADERS.AUTH_PASSWORD,
    SOA_HEADERS.AUTH_ESAMSTOKEN,
    SOA_HEADERS.AUTH_IAFTOKEN
], function (memo, item) {
    memo[item] = true;
    return memo;
}, {});

module.exports.instrument = function instrument(wsdl, options) {
    if (options.namespaces) {
        objectToXMLOverride(wsdl);

        if (options.namespaces.list) {
            for (var key in options.namespaces.list) {
                var opt = options.namespaces.list[key];
                if (opt.byParent) {
                    wsdl.namespaces.parent[key] = { ns: opt.ns || '' };
                }
                else {
                    wsdl.namespaces.element[key] = { ns: opt.ns || '' };
                }
            }
        }
    }
};

module.exports.objset = function objset(obj) {
    return {
        set: function set(key, value) {
            obj[key] = value;
            return this;
        },
        build: function build() {
            return obj;
        }
    };
};

module.exports.normalizeHeaders = function normalizeHeaders(headers) {
    headers = headers || {};
    return Object.keys(headers).reduce(function reduce(memo, key) {
        memo[/^X-EBAY-SOA/i.test(key) ? key.toUpperCase() : key] = headers[key];
        return memo;
    }, {});
};

function objectToXMLOverride(wsdl) {
    if (!wsdl.namespaces && !wsdl.namespaceByParent) {
        wsdl.namespaces = {
            parent: {},
            element: {},
            declaration: {},
            enabled: true
        };

        wsdl.objectToXML = objectToXML.bind(wsdl);
    }
}

function objectToXML(obj, name, namespace, xmlns, ctx) {
    /* jslint validthis: true */
    var first = ctx === true;
    name = first ? Object.keys(obj)[0] : name;
    obj = first ? obj[name] : obj;

    if (!/^\$|^\#/.test(name)) {

        if (first) {
            // get method

            var methodDef = this.definitions.messages[name];
            ctx = {};
            ctx[name] = methodDef.parts;
        }
    }

    var nsEnabled = namespace !== '';
    if (nsEnabled) {
        namespace = ctx ? ctx.targetNSAlias || namespace : namespace,
        xmlns = ctx ? ctx.targetNamespace || xmlns : xmlns;
    }

    var self = this;

    // var nsEnabled = this._namespaces.enabled;

    var parts = [],
        xmlnsAttrib = first && nsEnabled ? ' xmlns:' + namespace + '="' + xmlns + '"' : '';

    var ns = namespace && nsEnabled ? namespace + ':' : '';

    if (Array.isArray(obj)) {
        for (var i = 0, item; item = obj[i]; i++) {
            parts.push(self.objectToXML(item, name, namespace, xmlns, ctx));
        }
    }
    else if (name) {

        ns = namespace ? namespace + ':' : '';

        parts.push('<');
        parts.push([ns, name, xmlnsAttrib].join(''));

        addAttributes(obj, parts);
        parts.push('>');

        if (obj && typeof obj === 'object') {

            var nextCtx = ctx[name] || ctx[name + '[]'];

            if (nextCtx) {
                for (var key in obj) {
                    if (/^\$/.test(key) || /targetNSAlias|targetNamespace/.test(key)) {
                        if (key === '$value') {
                            parts.push(obj[key]);
                        }
                        continue;
                    }
                    parts.push(self.objectToXML(obj[key], key, nextCtx[key] ||
                        nextCtx[key + '[]'] ? namespace : '', xmlns, nextCtx));
                }
            }
        }
        else {
            parts.push(xmlEscape(obj));
        }
        parts.push(['</', ns, name, '>'].join(''));

    }
    else if (obj !== undefined) {
        parts.push(xmlEscape(obj));
    }
    return parts.join('');
}


function addAttributes(obj, parts) {
    if (obj && typeof obj === 'object') {
        Object.keys(obj).forEach(function forEach(attrName) {
            if (/^\$/.test(attrName) && attrName !== '$value') {
                parts.push(' ' + attrName.substring(1) + '=\'' + obj[attrName] + '\'');
            }
        });
    }
}

function xmlEscape(obj) {
    if (typeof(obj) === 'string') {
        return obj
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');
    }

    return obj;
}

function serialize(obj, secure) {
    var result = [];
    for (var key in obj) {
        if (key !== ATTRIB_ACCESSOR) {
            var value = obj[key];
            if (secure && SUCURE_HEADERS[key]) {
                value = '****';
            }
            result.push(key + '=' + value);
        }
    }
    return result.join('&');
}

module.exports.extend = function extend(dest, src, depth) {
    depth = depth || 1;
    if (src && depth >= 0) {
        for (var key in src) {
            var dValue = dest[key],
                sValue = src[key];
            if (dValue && typeof dValue === 'object' &&
                sValue && typeof sValue === 'object') {
                _.extend(dValue, sValue, depth - 1);
            } else {
                dest[key] = sValue;
            }
        }
    }
};
