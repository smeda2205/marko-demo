"use strict";

function findKey(obj, val) {
    for (var n in obj) {
        if (obj[n] === val) {
            return n;
        }
    }
}
var assert = require('assert');

var Builder = function(wsdl, options) {
    options = options || {};
    this.wsdl = wsdl;
    this._initializeOptions(options);
    this._initializeServices();
};

Builder.prototype.addSoapHeader = function(soapHeader, name, namespace, xmlns) {
    if (!this.soapHeaders) {
        this.soapHeaders = [];
    }
    if (typeof soapHeader === 'object') {
        soapHeader = this.wsdl.objectToXML(soapHeader, name, namespace, xmlns, true);
    }
    this.soapHeaders.push(soapHeader);
    return this;
};

Builder.prototype._initializeServices = function() {
    var definitions = this.wsdl.definitions,
        services = definitions.services;
    for (var name in services) {
        this[name] = this._defineService(services[name]);
    }
};

Builder.prototype._initializeOptions = function(options) {
    this.wsdl.options.attributesKey = options.attributesKey || 'attributes';
};

Builder.prototype._defineService = function(service) {
    var ports = service.ports,
        def = {};
    for (var name in ports) {
        def[name] = this._definePort(ports[name]);
    }
    return def;
};

Builder.prototype._definePort = function(port) {
    var binding = port.binding,
        methods = binding.methods,
        def = {};
    for (var name in methods) {
        def[name] = this._defineMethod(methods[name]);
        this[name] = def[name];
    }
    return def;
};

Builder.prototype._defineMethod = function(method) {
    var self = this;
    return function(args, callback) {
        if (typeof args === 'function') {
            callback = args;
            args = {};
        }

        return self._build(method, args);
    };
};

Builder.prototype._build = function(method, args) {
    var self = this,
        name = method.$name,
        input = method.input,
        output = method.output,
        style = method.style,
        defs = this.wsdl.definitions,
        ns = defs.$targetNamespace,
        encoding = '',
        message = '',
        xml = null,
        soapAction = method.soapAction || (((ns.lastIndexOf("/") !== ns.length - 1) ? ns + "/" : ns) + name),
        headers = {
            SOAPAction: '"' + soapAction + '"'
        },
        alias = findKey(defs.xmlns, ns);

    if (input.parts) {
        assert.ok(!style || style === 'rpc', 'invalid message definition for document style binding');
        message = self.wsdl.objectToRpcXML(name, args, alias, ns);
        (method.inputSoap === 'encoded') && (encoding = 'soap:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/" ');
    } else if (typeof(args) === 'string') {
        message = args;
    } else {
        assert.ok(!style || style === 'document', 'invalid message definition for rpc style binding');
        // pass `input.$lookupType` if `input.$type` could not be found
        message = self.wsdl.objectToDocumentXML(input.$name, args, input.targetNSAlias, input.targetNamespace, (input.$type || input.$lookupType));
    }
    xml = "<soap:Envelope " +
        "xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" " +
        "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " +
        encoding +
        this.wsdl.xmlnsInEnvelope + '>' +
        "<soap:Header>" +
        (self.soapHeaders ? self.soapHeaders.join("\n") : "") +
        (self.security ? self.security.toXML() : "") +
        "</soap:Header>" +
        "<soap:Body>" +
        message +
        "</soap:Body>" +
        "</soap:Envelope>";

    self.lastMessage = message;
    self.lastRequest = xml;

    return {
        headers: {
            'Content-Type': 'text/xml; charset=utf-8',
            SOAPAction: '"' + soapAction + '"'
        },
        body: xml,
        output: output
    };
};

Builder.prototype.build = function build(options) {
    return this[options.operation](options.request || options.body);
};

module.exports = Builder;
