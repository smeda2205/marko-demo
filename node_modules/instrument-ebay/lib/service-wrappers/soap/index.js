"use strict";

var Assert = require('assert');
var Fs = require('fs');
var Util = require('util');
var Objutil = require('objutil');
var asyncwrap = require('instrument-inc/wrappers').asyncwrap;
var open_wsdl = require('soap-temp-ebay/lib/wsdl').open_wsdl;
var DataHolder = require('raptor-async/DataHolder');
var Builder = require('./builder');
var Adaptor = require('./adaptor');
var Utils = require('./utils');
var _ = require('underscore');

var builders = {};

var _wsdlCache = {};

module.exports = function soap(transport) {

    return asyncwrap(transport, function before(options, next) {

        createBuilder(options, function buildRequest(err, builder) {
            if (err) {
                return next(err);
            }

            Utils.instrument(builder.wsdl, options);

            var start = Date.now();
            var requestOptions = builder.build(options);
            var marshalTime = Date.now() - start;

            // update metrics if exists
            this.metrics = this.ctx && this.ctx().metrics;
            if (this.metrics) {
                this.metrics.update('marshalTime', marshalTime);
            }

            delete options.body;
            Objutil.deepMerge(options, requestOptions);

            this.builder = builder;
            this.output = requestOptions.output;
            delete requestOptions.output;

            Adaptor.adapt(requestOptions, this.builder.wsdl);
            requestOptions.headers = Utils.normalizeHeaders(requestOptions.headers);

            next(null, requestOptions);
        }.bind(this));

    }, function after(err, response, next) {

        var args = Array.prototype.slice.call(arguments);
        next = args.pop();
        err = args.shift();
        response = args.shift();

        if (err) {
            return next(err);
        }

        response.body = response.body.toString();

        var start = Date.now();
        var obj = tryXmlToObject(this.builder.wsdl, response);
        var unmarshalTime = Date.now() - start;
        if (this.metrics) {
            this.metrics.update('unmarshalTime', unmarshalTime);
        }

        if (obj instanceof Error) {
            if (response.statusCode >= 300) {
                obj = boom(response);
            }
            return next(obj);
        }

        response.body = obj.Body[this.output .$name];
        // RPC/literal response body may contain elements with added suffixes I.E.
        // 'Response', or 'Output', or 'Out'
        // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5
        if (!response.body) {
            response.body = obj.Body[this.output .$name.replace(/(?:Out(?:put)?|Response)$/, '')];
        }

        if (err ||
            response.statusCode >= 400 ||
            response.body && response.body.errorMessage) {

            return next(err || boom(response.statusCode >= 400 ? response : response.body));
        }

        response.headers = response.headers ||
            response.body && response.body.headers;

        // to preserve backward compatibility
        response.__attrib = response.attributes;

        next(err, response);
    });

};

function tryXmlToObject(wsdl, response) {
    try {
        return wsdl.xmlToObject(response.body);
    } catch (error) {
        return new Error(error.message + ', response:' + response.body);
    }
}

function boom(response) {

    var err;

    if (response && response.errorMessage) {
        err = _.extend(new Error('Server returned error: ' +
                Util.inspect(response.errorMessage)),
                    {errorMessage: response.errorMessage});
        err.code = 'ServerError';
        err.response = response;
    }
    else {
        err = new Error('Status code: ' +
            (response && response.statusCode || '500') +
            ', message: ' +
            (response.body || 'Unknown error'));
        err.statusCode = response && response.statusCode || 500;
        err.code = 'HTTP' + err.statusCode;
        err.response = response;
    }

    return err;
}

var loadWSDL = module.exports.loadWSDL = function loadWSDL(options, callback) {

    Assert.ok(options.wsdl, 'WSDL file must be provided');

    // allow only file based WSDL
    Assert.ok(Fs.existsSync(options.wsdl), 'Cannot find location of wsdl file');

    var wsdl = _wsdlCache[options.wsdl];
    if (wsdl) {
        process.nextTick(function() {
            callback(null, wsdl);
        });
    } else {
        open_wsdl(options.wsdl, options, function(err, wsdl) {
            if (err) {
                return callback(err);
            }
            else {
                _wsdlCache[options.wsdl] = wsdl;
            }
            callback(null, wsdl);
        });
    }
};

var createBuilder = module.exports.createBuilder = function createBuilder(options, callback) {
    var args = [].slice.call(arguments);
    callback = args.pop();
    options = args.shift();

    var id = options.clientId || options.wsdl;
    var builderHolder = builders[id] = builders[id] || (function () {
        var holder = new DataHolder();
        loadWSDL(options, function(err, wsdl) {
            if (err || !wsdl) {
                delete builders[id];
                return holder.reject(err || new Error('Cannot load wsdl file: ' + options.wsdl));
            }
            holder.resolve(new Builder(wsdl, options));
        });
        return holder;
    })();

    builderHolder.done(callback);
};

module.exports.SOA_HEADERS = require('./soa-headers');
module.exports.reset = function reset() {
    _wsdlCache = {};
};
