'use strict';

var fs = require('node-fs'),
    vm = require('vm'),
    nodePath = require('path'),
    cheerio = require('cheerio'),
    marko = require('marko-v2'),
    logger = require('logging-inc').logger('global-header-ebay/templify'),
    markoCompiler = require('marko-v2/compiler');

var cacheDir = nodePath.join(process.cwd(), '.cache/global-header');
var debug = require('debug')('header:templify');
var _0777 = parseInt('0777', 8);
var SCENARIO_ENUM = {
    'HEADER': 'header',
    'FOOTER': 'footer'
};

function generateTempFilename() {

    var now = new Date();
    return [
            now.getYear(),
            now.getMonth(),
            now.getDate(),
            process.pid,
            (Math.random() * 0x100000000 + 1).toString(36)
        ].join('-');
}

try {
    fs.mkdirSync(cacheDir, _0777, true);
} catch (e) {}

/**
 * @desc This method is to fix the tracking for AMP.
 * It appends the application Page Id to the _trksid param
 * The application page id is the experience service operation ID.
 * @param {Object} $ parsed HTML
 */
function normalizeAmpTracking ($) {
    var attrVal;
    $('[data-amp-addparams]').each(function() {
        attrVal = $(this).attr('data-amp-addparams');
        if (attrVal) {
            attrVal = attrVal.replace(/(=)(m\d+\.l\d+)/, '$1\${data.modifiedApplicationPageId}$2');
            $(this).attr('data-amp-addparams', attrVal);    
        }
    });
    var hiddenInput = $('input[name="_trksid"]');
    var hiddenValue = hiddenInput.attr('value');
    if (hiddenValue) {
        hiddenValue = hiddenValue.replace(/(m\d+\.l\d+)/, '${data.modifiedApplicationPageId}$1');
        hiddenInput.attr('value', hiddenValue);
    }
}

/**
 * @desc Uses cheerio to parse the Header HTML, create the DOM and make DOM manipulations
 * @param {*} html 
 */
function parseFooter(html) {
    /*
    What we do here is use Cheerio to parse the HTML and build a DOM. Cheerio then
    gives us a jQuery API that we can use to query and modify the DOM. We use this
    functionality to update various DOM attributes with Raptor Templates directives.
    Finally, we convert the DOM back to HTML and then compile it using
    the Raptor Templates compiler to produce a template object with a render method.
    No regular expressions! Awesome!
     */
    var st = Date.now();
    var $ = cheerio.load(html, {
        decodeEntities: true
    });
    debug('cheerio: Loaded HTML in ' + (Date.now() - st) + 'ms');
    st = Date.now();
    normalizeAmpTracking($);
    debug('cheerio: Manipulated DOM in ' + (Date.now() - st) + 'ms');
    st = Date.now();
    html = $.html({
        decodeEntities: false
    });
    debug('cheerio: Generated HTML in ' + (Date.now() - st) + 'ms');
    return html;
}

/**
 * @desc Uses cheerio to parse the Footer HTML, create the DOM and make DOM manipulations
 * @param {*} html 
 */
function parseHeader(html) {
    /*
    What we do here is use Cheerio to parse the HTML and build a DOM. Cheerio then
    gives us a jQuery API that we can use to query and modify the DOM. We use this
    functionality to update various DOM attributes with Raptor Templates directives.
    Finally, we convert the DOM back to HTML and then compile it using
    the Raptor Templates compiler to produce a template object with a render method.
    No regular expressions! Awesome!
     */

    var st = Date.now();

    var $ = cheerio.load(html);
    debug('cheerio: Loaded HTML in ' + (Date.now() - st) + 'ms');

    normalizeAmpTracking($);
    st = Date.now();
    // All for the keywords input to be populated with keywords
    $("[name='_nkw']").attr('value', '$data.searchKeywords');

    $("style").attr('nonce', '$data.cspnonce');

    var scriptTags = $('#gh-eb-u script').text();
    $('#gh-eb-u script').remove();
    $('#gh-eb-u').append('<script nonce="$data.cspnonce">'+scriptTags+'</script>');

    // Allow the search form action to be changed
    var oldAction = $("#gh-f").attr('action');
    $("#gh-f").attr('action', '${data.searchFormAction || ' + JSON.stringify(oldAction) + '}');

    // Allow for hidden input fields to be added
    $("#gh-f").prepend('<input type="hidden" name="$hidden.name" value="$hidden.value" for="hidden in data.searchFormFields">');

    /**
    /* Categories - <select>
    **/
    // L2, L3, etc categories: refinedCategoriesArr comes from refinedCategories attribute
    // After the first category, an "L" character is prepended to category name
    $('#gh-cat').append('<option for="category in data.refinedCategoriesArr; status-var=loop" value="$category.value" selected="$category.selected"><if test="!loop.isFirst()">&#9492;</if>$category.key</option>');

    //allCategoriesText
    var oldAllCategoriesText = $('#gh-cat option[value="0"]').text();
    $('#gh-cat option[value="0"]').remove();
    $('#gh-cat').append('<option if="data.allCategoriesText" value="0">${data.allCategoriesText}</option>');
    $('#gh-cat').append('<option if="!data.allCategoriesText" value="0">'+oldAllCategoriesText+'</option>');

    // Separator between the L2+ and L1 - if the L1 list was passed in
    $('#gh-cat').append('<optgroup if="notEmpty(data.categoriesArr)" label="----------------------------------------"></optgroup>');

    // L1 level categories: categoriesArr from categories tag attribute
    $('#gh-cat').append('<option for="category in data.categoriesArr" value="$category.value" selected="$category.selected">$category.key</option>');

    /** end Categories **/


    debug('cheerio: Manipulated DOM in ' + (Date.now() - st) + 'ms');

    st = Date.now();
    html = $.html();
    debug('cheerio: Generated HTML in ' + (Date.now() - st) + 'ms');

    return html;
}

/**
 * @desc Generates the marko template with the parsed HTML
 * @param {*} html parsed HTML 
 * @param {*} scenarioEnum Header / Footer
 * @param {*} callback callback to be called 
 */
function generateTemplate(html, scenarioEnum, callback) {
    var filename = generateTempFilename();
    var outFile = nodePath.join(cacheDir, filename + '.marko.js');
    var codeToCompile;
    logger.info('Generating template for ', scenarioEnum);
    try {
        // no actual file is created
        var compiled = markoCompiler.compile(html, outFile);

        // This is a hack to avoid memory leak due to re-loading of template
        // strip out module exports
        compiled = compiled.substring(0, compiled.indexOf('(module.exports'));
        // compile and load it
        codeToCompile = '(function createTemplate() { return {'+
            'create:' + compiled +
        '}; })();';
        var templateModule = vm.runInThisContext(codeToCompile);
        var template = marko.load(templateModule);
        // validate the module if it is renderable
        template.render({}, {
            write: function writeNone() {
            },
            end: function endNone(err) {
                if (err) {
                    // failed to render
                    logFailedToParseOrRender(err);
                    return callback(err);
                }
                callback(null, template);
            }
        });
    }
    catch (err) {
        logFailedToParseOrRender(err);
        return callback(err);
    }

    /**
    * @desc Logs any error that may have occurred
    * @param {*} err 
    */
    function logFailedToParseOrRender(err) {
        logger.warn('Global ', scenarioEnum, ' html content:', html);
        if (codeToCompile) {
            logger.warn('Global ', scenarioEnum, ' compiled code:', codeToCompile);
        }
        logger.error('invalid global ', scenarioEnum, ' content, failed to parse or render', err);
    }
}

/**
 * @desc Header invokes this to modify HTML, parse, generate footer template
 */
exports.header = function (html, callback) {
    try {
        html = parseHeader(html);
    }
    catch (err) {
        logger.warn('Global header html content:', html);
        logger.error('failed to parse GH content into html dom and inject dynamic content', err);
        return callback(err);
    }
    generateTemplate(html, SCENARIO_ENUM.HEADER, callback);
};

/**
 * @desc Footer invokes this to modify HTML, parse, generate footer template
 */
exports.footer = function (html, callback) {
    try {
        html = parseFooter(html);
    }
    catch (err) {
        logger.warn('Global footer html content:', html);
        logger.error('failed to parse Global Footer content into html dom and inject dynamic content', err);
        return callback(err);
    }
    generateTemplate(html, SCENARIO_ENUM.FOOTER, callback);
};
