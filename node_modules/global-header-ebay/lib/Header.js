'use strict';

var utils = require('./utils'),
    styleGrabber = utils.getPattern('style'),
    scriptGrabber = utils.getPattern('script'),
    commentGrabber = utils.getPattern('comment'),
    customAttributeGrabber = utils.getPattern('customAttribute'),
    importantStyleGrabber = /\s*!\s*important/gim;

var logger = require('logging-inc').logger('global-header-ebay/Header');

function Header(headerResponse, jsOptions) {
    var js = headerResponse.js;
    if (js) {
        if (!Array.isArray(js)) {
            js = [js];
        }
    }

    var css = headerResponse.css;
    if (css) {
        if (!Array.isArray(css)) {
            css = [css];
        }
    }

    this._jsOptions = jsOptions;
    this.inlineJS = headerResponse['js.inline'];
    this.inlineCSS = headerResponse['css.inline'];
    this.js = js;
    this.css = css;
    this.html = headerResponse.html;
    this._htmlTemplate = headerResponse.htmlTemplate;
}

Header.prototype = {
    render: function (options, context) {
        if (!options) {
            throw new Error('"options" argument is required');
        }
        options.modifiedApplicationPageId = '';
        if (options.var === 'amp' && options.applicationPageId) {
            options.modifiedApplicationPageId = 'p' + options.applicationPageId + '.';
        }
        // Options that matter now are things like "searchKeywords" and "searchAction"
        // which we will feed in as part of the view model to the template to produce
        // the final HTML

        //categories: in the format -> categories="testCat1:100,testCat2:200"
        // - since commas delineate the elements, "&comma;" can used as a placeholder - eg "ipods&comma; cameras:100"
        // - determine if <option> should be selected.  catArr[1] is number, which options.categoryId is a string
        options.categoriesArr = [];
        if(options.categories !== undefined && options.categories !== null) {
            options.categories = options.categories.toString();
            options.categories.split(',').forEach(function (category) {
                var catArr = category.split(':');
                var catName = catArr[0].replace(/&comma;/g,',').replace(/&colon;/g,':');
                var catSelected = (catArr[1] == options.categoryId) ? 'selected' : '';
                options.categoriesArr.push({key: catName, value: catArr[1], selected: catSelected });
            });
        }

        //refinedCategories: in the format -> refinedCategories="topCat1:300,topCat2:900"
        // - since commas delineate the elements above, "&comma;" can used as a placeholder - eg "ipods&comma; cameras:100"
        // - determine if <option> should be selected.  catArr[1] is number, which options.categoryId is a string
        options.refinedCategoriesArr = [];
        if(options.refinedCategories !== undefined && options.refinedCategories !== null) {
            options.refinedCategories = options.refinedCategories.toString();
            options.refinedCategories.split(',').forEach(function (refinedCategory) {
                var refinedCatArr = refinedCategory.split(':');
                var refinedCatName = refinedCatArr[0].replace(/&comma;/g,',').replace(/&colon;/g,':');
                var refinedCatSelected = (refinedCatArr[1] == options.categoryId) ? 'selected' : '';
                options.refinedCategoriesArr.push({key: refinedCatName, value: refinedCatArr[1], selected: refinedCatSelected } );
            });
        }

        options.cspnonce = fetchNonce(context);

        var asyncOut = context.beginAsync();
        try {
            this._htmlTemplate.render(options, function(err, html, out) {
                asyncOut.write(html);
                asyncOut.end();
            });
        }
        catch (err) {
            logger.error('Failed to render the header', err);
            asyncOut.end(err);
        }
    },

    renderAMP: function(context) {
        var html = this.html;
        if (!html) {
            return;
        }

        var ampHTML = html
                        .replace(styleGrabber, '') // Strip the style tags
                        .replace(scriptGrabber, '') // Strip the script tags
                        .replace(commentGrabber, '') // Strip the HTML comments
                        .replace(customAttributeGrabber, ''); // Strip the custom _sp attribute
        if (!ampHTML) {
            return;
        }

        // Check if <header> tag is already present
        if (ampHTML.indexOf('</header>') !== -1) {
            context.write(ampHTML);
        } else {
            context.write('<header>' + ampHTML + '</header>');
        }
    },

    renderJS: function(context) {
        var js = this.js;
        var nonce = fetchNonce(context);

        if (!js) {
            return;
        }

        for (var i = 0, len = js.length; i < len; i++) {
            context.write('<script type="text/javascript" src="' + js[i] + '"></script>');
        }

        this._jsOptions = this._jsOptions || '';
        if (this.inlineJS) {
            var noncePH = nonce ? 'nonce="'+nonce+'"' : '';
            context.write('<script type="text/javascript" '+noncePH+'>' + this.inlineJS + this._jsOptions + '};GH.init();}</script>');
        }
    },

    renderAMPCSS: function(context) {
        var html = this.html;
        if (!html) {
            return;
        }

        var styles = [];
        html.replace(styleGrabber, function(styleTag, styleContent) {
            // Strip out the '!important style rule'
            var styleString = styleContent.replace(importantStyleGrabber, '');
            styles.push(styleString);
        });

        context.write(styles.join(' '));
    },

    renderCSS: function (context) {
        var css = this.css;

        if (!css) {
            return;
        }

        for (var i = 0, len = css.length; i < len; i++) {
            context.write('<link rel="stylesheet" type="text/css" href="' + css[i] + '">');
        }
    }
};

function fetchNonce(context) {
   var nonce = '';
   if (context.stream && context.stream.req) {
       var req = context.stream.req;
       if (req.csp && req.csp.nonce) {
           nonce = req.csp.nonce;
       }
   }
   return nonce;
}

module.exports = Header;
