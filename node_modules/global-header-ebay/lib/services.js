'use strict';

var templify = require('./templify'),
    querystring = require('querystring'),
    svcclient = require('service-client-ebay'),
    modConfig = require('module-config-inc'),
    queryStringBuilder = require('./query-string-builder'),
    debug = require('debug')('global-header-ebay:services');

var Utils = require('./utils');
var Fallback = require('./fallback');
var logger = require('logging-inc').logger('global-header-ebay/services');

var Cache = require('./cache');

var config;

var extend = require('raptor-util/extend');

/**
 * Initialize and cache config
 */
function _initConfig(callback) {
    if (config) {
        return callback();
    }

    modConfig(module, function (err, _config) {
        config = _config;
        Cache.configure(config.get('globalheader').cache);
        config.on('change', function () {
            Cache.configure(config.get('globalheader').cache);
        });
        return callback();
    });
}

function _globalHeaderService(queryStr, cacheKey, callback) {
    var st = Date.now();

    var qs = querystring.parse(queryStr) || {};

    svcclient.getClient('globalheader').get(qs).end(function (error, response) {

        debug('Header service call completed in', Date.now() - st, 'ms');

        if (error || response.statusCode >= 300) {
            error = error || new Error('Bad response from service, status: ' +
                response.statusCode);
            handleFallback(error, callback);
            return;
        }

        var body = response.body;
        if (Buffer.isBuffer(response.body)) {
            var result = Utils.tryParse(body.toString('utf8'));
            if (result.err) {
                handleFallback(result.err, callback);
                return;
            }
            body = result.data;
        }
        var headerSpec = body;

        templify.header(headerSpec.html, function (err, template) {
            if (err) {
                handleFallback(err, callback);
                return;
            }
            headerSpec.htmlTemplate = template;

            debug('Caching Header service, key', cacheKey);
            Cache.set(cacheKey, headerSpec); //Cache response;

            return callback && callback(null, headerSpec);
        });
    });

    function handleFallback(error, callback) {
        if (callback) {
            debug('handling fallback for header');
            Cache.get(cacheKey, Cache.TYPE.FALLBACK, function onValue(err, cachedCopy) {
                if (err) {
                    logger.error('got an error while getting cold cache header', err);
                }
                if (cachedCopy) {
                    logger.warn('using header back up cache due to error', error);
                    return callback(null, cachedCopy);
                }
                if (!config.get('globalheader:fallback')) {
                    logger.error('No fallback available for header as it is disabled');

                    return callback(error);
                }

                logger.warn('falling to static version due to error', error);
                // try to use static fallback
                Fallback.getHeader(qs, function handleFallback(err, headerSpec) {
                    if (err) {
                        logger.error('Failed to use static fallback due to ', err);
                        return callback(error);
                    }
                    if (headerSpec) {
                        return callback(null, headerSpec);
                    }
                    err = new Error('No header is available');
                    logger.fatal(err);
                    callback(err);
                });
            });
        }
    }
}

function _globalFooterService(queryStr, cacheKey, callback) {
    var st = Date.now();
    var qs = querystring.parse(queryStr) || {};
    svcclient.getClient('globalfooter').get(qs).end(function (error, response) {
        debug('Footer service call completed in', Date.now() - st, 'ms');
        if (error || response.statusCode >= 300) {
            error = error || new Error('Bad response from service, status: ' +
                response.statusCode);
            logger.error(error);
            handleFallback(error, callback);
            return;
        }
        var body = response.body;
        if (Buffer.isBuffer(body)) {
            try {
                var result = body.toString('utf8');
                body = result;
            } catch (err) {
                handleFallback(err, callback);
                return;
            }
        }
        var footerSpec = {
            html: body
        };
        templify.footer(footerSpec.html, function (err, template) {
            if (err) {
                handleFallback(err, callback);
                return;
            }
            footerSpec.htmlTemplate = template;
            debug('Caching Footer service, key', cacheKey);
            Cache.set(cacheKey, footerSpec); //Cache response;
            return callback && callback(null, footerSpec);
        });
    });

    function handleFallback(error, callback) {
        if (callback) {
            debug('falling to cold cache for the footer');
            Cache.get(cacheKey, Cache.TYPE.FALLBACK, function onValue(err, cachedCopy) {
                if (err) {
                    logger.error('got an error while getting cold cache footer', err);
                }
                if (cachedCopy) {
                    logger.warn('using footer back up cache due to error', error);
                    return callback(null, cachedCopy);
                }
                if (!config.get('globalheader:fallback')) {
                    logger.error('No fallback available for footer as it is disabled');
                    return callback(error);
                }
                logger.warn('falling to static version due to error', error);
                // try to use static fallback
                Fallback.getFooter(qs, function handleFallback(err, footerSpec) {
                    if (err) {
                        logger.error('Failed to use static fallback due to ', err);
                        return callback(error);
                    }
                    if (footerSpec) {
                        return callback(null, footerSpec);
                    }
                    logger.error('No static footer is available', error);
                    callback(error);
                });
            });
        }
    }
}

/**
 * 1. Use the cached copy
 * 2. If no cached copy, check backup cached copy
 *  2.1 If backup cached copy available,
 *    2.1.1 Recache the main cache
 *    2.1.2 Call service for fresh copy.
 *    2.1.3 Cache it in the main cache
 *    2.1.4 Remove it from the backup cache
 *  2.2 If no cache,
 *    2.2.1 Call service
 *    2.2.2 Cache it
 * 3. If the cached copy is disposing
 *  3.1 Backup it in backup cache
 */
function _globalHeader(params, callback) {
    var queryStr = queryStringBuilder.header(params),
        cacheKey = 'GH_' + queryStr,
        cachedCopy = Cache.get(cacheKey);

    debug(queryStr);
    if (cachedCopy) {
        debug('using cached header for', cacheKey);
        return callback(null, cachedCopy);
    } else {
        debug('no cache found for', cacheKey);
        // trigger service refresh if we got entry from backup/fallback
        Cache.get(cacheKey, Cache.TYPE.BACKUP, function onValue(err, cachedCopy) {
            if (cachedCopy) {
                debug('using fallback header');
                callback(null, cachedCopy);
                _globalHeaderService(queryStr, cacheKey);
                return;
            }
            _globalHeaderService(queryStr, cacheKey, callback);
        });

    }
}

function _isEmptyStr(obj) {
    return ( typeof obj === 'string' || obj instanceof String ) && obj.trim().length === 0;
}

function _checkCategoryId(params) {
    params = params || {};
    var keys = Object.keys(params);
    if( keys.indexOf('categoryId') < 0 ) {
        return params;
    }
    var paramsClone = {};
    paramsClone = extend(paramsClone, params);
    var categoryId = paramsClone.categoryId;
    if( categoryId === null || categoryId === undefined || _isEmptyStr(categoryId) ) {
        delete paramsClone.categoryId;
    }
    return paramsClone;
}

function _globalFooter(params, callback) {

    //FIX EMPTY STR ERROR FOR categoryId during string conversion to int
    params = _checkCategoryId(params);

    var queryStr = queryStringBuilder.footer(params),
        cacheKey = 'GF_' + queryStr,
        cachedCopy = Cache.get(cacheKey);

    debug(queryStr);

    if (cachedCopy) {
        debug('using cached footer');
        return callback(null, cachedCopy);
    } else {
        Cache.get(cacheKey, Cache.TYPE.BACKUP, function onValue(err, cachedCopy) {
            if (cachedCopy) {
                debug('using backup cached footer');
                callback(null, cachedCopy);
                _globalFooterService(queryStr, cacheKey);
                return;
            }
            _globalFooterService(queryStr, cacheKey, callback);
        });
    }
}

function loadGlobalHeader(params, callback) {
    _initConfig(function (errors, result) {
        return _globalHeader(params, callback);
    });
}

function loadGlobalFooter(params, callback) {
    _initConfig(function (errors, result) {
        return _globalFooter(params, callback);
    });
}

module.exports = {
    loadHeader: loadGlobalHeader,
    loadFooter: loadGlobalFooter
};
