'use strict';

var Assert = require('assert');
var NodeUtils = require('util');
var Cache = require('lru-backup-cache');
var Objutil = require('objutil');
var debug = require('debug')('global-header-ebay/cache');
var RaptorCache = require('raptor-cache');
var Objpath = require('object-path');

var Templify = require('./templify');

var logger = require('logging-inc').logger('global-header-ebay/cache');

var DEFAULT_COLD_CACHE_REFRESH_INTERVAL = 60 * 1000;

var TYPE = {
    BACKUP: 1,
    FALLBACK: 2
};

module.exports.TYPE = TYPE;

module.exports.reset = function reset() {
    this.lastCleanup = 0; //TODO: cannot use timestamp yet till config bean starts supporting date type
    this.config = undefined;
    this.lastColdCacheUpdate = {};
    this.cache = undefined;
    this.cacheEnabled = false;
    this.coldCache = undefined;
    this.coldCacheEnabled = false;
};

module.exports.configure = function configure(cacheConfig) {

    // check if cache in general should be disabled
    if (!cacheConfig || !cacheConfig.enable) {
        this.coldCacheEnabled = false;
        this.cacheEnabled = false;
        return;
    }

    var requestCleanup = Objpath.get(cacheConfig,
        'lastCleanup', this.lastCleanup);
    var needToClearCache = this.lastCleanup < requestCleanup;
    this.lastCleanup = requestCleanup;

    var needToReconfigureCache =
        Objpath.get(this, 'config.maxAge', 0) !== Objpath.get(cacheConfig, 'maxAge', 0) ||
        Objpath.get(this, 'config.max', 0) !== Objpath.get(cacheConfig, 'max', 0);

    // since this call can be called frequently, it should not reset existing data
    this.cacheEnabled = true;
    this.lastColdCacheUpdate = this.lastColdCacheUpdate || {};

    if (!this.cache ||
        needToReconfigureCache ||
        needToClearCache) {

        var oldCache = this.cache;
        this.cache = new Cache(cacheConfig);
        if (oldCache) {
            if (!needToClearCache) {
                // copy from old to new
                oldCache._cache.rforEach(function forEach(value, key) {
                    this.cache._cache.set(key, value);
                }.bind(this));

                // copy backup from old to new
                oldCache._backupCache.rforEach(function forEach(value, key) {
                    this.cache._backupCache.set(key, value);
                }.bind(this));
            }
        }
    }

    // check if cold cache should be disabled
    this.coldCacheEnabled = !!(cacheConfig.cold && cacheConfig.cold.enable);
    if (this.coldCacheEnabled) {
        var needToReconfigureColdCache =
            Objpath.get(this, 'config.cold.freeDelay', 0) !== Objpath.get(cacheConfig,
                'cold.freeDelay', 0) ||
            Objpath.get(this, 'config.cold.flushDelay', 0) !== Objpath.get(cacheConfig,
                'cold.flushDelay', 0);

        var nodeEnv = (process.env.NODE_ENV || 'development').toLowerCase();
        if (!this.coldCache || needToReconfigureColdCache) {
            this.coldCache = RaptorCache.createDiskCache(Objutil.mixin(cacheConfig.cold, {
                dir: '.cache/global-header-ebay-' + nodeEnv,
                serialize: serialize,
                deserialize: deserialize
            }));
        }
    }

    this.config = cacheConfig;
};

module.exports.set = function set(cacheKey, spec) {
    if (!this.cacheEnabled) {
        debug('caching disabled');
        return;
    }

    this.cache.set(cacheKey, spec);

    this.toColdCache(cacheKey, spec);
};

/*
 * in memory cache is sync, while for any fallback one should provide callback
*/
module.exports.get = function get(cacheKey, type, callback) {
    var args = [].slice.call(arguments);
    cacheKey = args.shift();
    callback = args.pop();
    type = args.shift() || TYPE.BACKUP;
    if (typeof callback !== 'function') {
        type = callback;
        callback = undefined;
    }

    if (!this.cacheEnabled) {
        if (callback) {
            callback();
        }
        return;
    }

    var spec = this.cache.get(cacheKey);
    if (spec || type === undefined) {
        debug('using backup spec if any');
        return callback ? callback(null, spec) : spec;
    }

    spec = this.cache.getBackup(cacheKey);
    if (spec || type === TYPE.BACKUP) {
        // return it back to primary cache from backup
        this.cache.set(cacheKey, spec);
        debug('using backup spec', spec);
        return callback ? callback(null, spec) : spec;
    }

    if (!this.coldCacheEnabled) {
        logger.warn('globalheader cold cache is disabled');
        return callback && callback();
    }

    // from this point the cache is async
    Assert.ok(callback, 'callback should be provide to access fallback entries');

    logger.warn(new Error(NodeUtils
        .format('Cannot find any cached version of global header/footer, will use cold cache, key: %s',
        cacheKey)));

    this.fromColdCache(cacheKey, callback);
};

module.exports.fromColdCache = function fromColdCache(cacheKey, callback) {
    this.coldCache.get(cacheKey, function onCacheRead(err, spec) {
        if (err || !spec) {
            return callback(err);
        }
        // if header is requested
        if (/^GH_/.test(cacheKey)) {
            // load header
            Templify.header(spec.html, function (err, template) {
                if (err) {
                    logger.error('Failed to parse template from cold cache ', cacheKey, err);
                    callback(err);
                    return;
                }
                spec.htmlTemplate = template;
                return callback(null, spec);
            });
            return;
        }
        // added to call Templify for footer (for AMP tracking lexbrwfe)
        // load footer
        if (spec.html) {
            Templify.footer(spec.html, function (err, template) {
                if (err) {
                    logger.error('Failed to parse template from cold cache ', cacheKey, err);
                    callback(err);
                    return;
                }
                spec.htmlTemplate = template;
                return callback(null, spec);
            });
        }
        callback(null, spec);
    });

};

module.exports.toColdCache = function toColdCache(cacheKey, spec) {
    if (!this.coldCacheEnabled) {
        return;
    }

    // when dumping, we should exclude compiled template if any
    if (spec.htmlTemplate) {
        spec = Objutil.mixin(spec, {});
        delete spec.htmlTemplate;
    }

    var lastDump = this.lastColdCacheUpdate[cacheKey] || 0;

    var coldConfig = this.config.cold;
    var refreshInterval = coldConfig.refreshInterval || DEFAULT_COLD_CACHE_REFRESH_INTERVAL;
    if (Date.now() - lastDump > refreshInterval) {
        this.lastColdCacheUpdate[cacheKey] = Date.now();

        this.coldCache.put(cacheKey, spec);
    }
};

function serialize(data) {
    return JSON.stringify(data);
}

function deserialize(reader, callback) {
    var json = '';

    reader()
        .on('data', function(data) {
            json += data;
        })
        .on('end', function() {
            try {
                callback(null, JSON.parse(json));
            }
            catch (err) {
                callback(err);
            }
        })
        .on('error', function(err) {
            callback(err);
        });
}
