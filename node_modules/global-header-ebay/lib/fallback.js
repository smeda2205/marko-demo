'use strict';

var Fs = require('fs');

var RaptorCache = require('raptor-cache');
var Objutil = require('objutil');

var Utils = require('./utils');
var Templify = require('./templify');

var debug = require('debug')('global-header-ebay/fallback');

var cache;

var HEADER_KEY_ORDER = {
    type: 'FULL',
    siteid: '0',
    var: '',
    secure: '0'
};

var FOOTER_KEY_ORDER = {
    type: 'NORMAL',
    siteid: '0',
    var: '',
    secure: '0'
};

function getResource(key, callback) {
    cache.get(
    key,
    function builder(next) { // This function will be called if the value has not been cached
        loadResource(key, next);
    },
    callback);
}

module.exports.getHeader = function getHeader(options, callback) {
    // this defines the fallback order with default values
    var fallbackDefaults = {
        type: 'FULL',
        var: '',
        siteid: 0,
        secure: 0
    };
    // keys will get initial snapshot of fallback order
    // and each key will be taked away from the list
    // and used to set default value from fallbackDefaults
    var keys = Object.keys(fallbackDefaults);

    // options object will have a state from previous failed attempt
    // we do not need to clone the options as it is used just
    // for this single request

    // initiate the first attempt
    loadPermutation();

    function loadPermutation() {
        var key = generateHeaderKey(options) + '.json';
        debug('using static header', key);
        getResource(key, function onHeader(err, headerSpec) {
            if (err) {
                // do fallback till exhausted all default keys
                if (keys.length) {
                    // take a key to try and remove it
                    // from the list at the same time
                    var key = keys.shift();
                    // set the new default value to options to try
                    options[key] = fallbackDefaults[key];
                    // re-start the cycle with this new options permutation
                    return loadPermutation();
                }
                // fail
                callback(err);
                return;
            }
            Templify.header(headerSpec.html, function (err, template) {
                if (err) {
                    callback(err);
                    return;
                }
                headerSpec.htmlTemplate = template;
                return callback && callback(null, headerSpec);
            });
        });
    }
};

module.exports.getFooter = function getFooter(options, callback) {
    // this defines the fallback order with default values
    var fallbackDefaults = {
        type: 'NORMAL',
        var: '',
        siteid: 0,
        secure: 0
    };
    // keys will get initial snapshot of fallback order
    // and each key will be taked away from the list
    // and used to set default value from fallbackDefaults
    var keys = Object.keys(fallbackDefaults);

    // options object will have a state from previous failed attempt
    // we do not need to clone the options as it is used just
    // for this single request

    // initiate the first attempt
    loadPermutation();

    function loadPermutation() {
        var key = generateFooterKey(options) + '.json';
        debug('using static footer', key);

        getResource(key, function onLoad(err, footerSpec) {
            if (err) {
                // do fallback till exhausted all default keys
                if (keys.length) {
                    // take a key to try and remove it
                    // from the list at the same time
                    var key = keys.shift();
                    // set the new default value to options to try
                    options[key] = fallbackDefaults[key];
                    // re-start the cycle with this new options permutation
                    return loadPermutation();
                }
                // fail
                callback(err);
                return;
            }
            Templify.footer(footerSpec.html, function (err, template) {
                if (err) {
                    callback(err);
                    return;
                }
                footerSpec.htmlTemplate = template;
                return callback && callback(null, footerSpec);
            });
        });
    }
};

function generateKey(options, spec, prefix) {

    // filter only allowed options
    options = Object.keys(spec).reduce(function reduce(memo, key) {
        var val = options[key];
        memo[key] = val !== undefined ? val : spec[key];
        return memo;
    }, {});

    return Utils.generateKey(options, prefix);
}

function generateHeaderKey(options) {
    return generateKey(options || {}, HEADER_KEY_ORDER, 'header');
}

function generateFooterKey(options) {
    return generateKey(options || {}, FOOTER_KEY_ORDER, 'footer');
}

function tryResolve(name) {
    try {
        return require.resolve(name);
    }
    catch (err) {
        return;
    }
}

function loadResource(name, callback) {
    var resourcePath = 'global-header-resources-ebay/resources/' + name;
    var path = tryResolve(resourcePath);
    if (path) {
        Fs.readFile(path, function onFileRead(err, data) {
            if (err) {
                return callback(err);
            }
            data = Utils.tryParse(data);
            if (data) {
                return callback(null, data.data);
            }
            callback(new Error('Failed to parse ' + resourcePath));
        });
    }
    else {
        callback(new Error('Failed to find ' + resourcePath));
    }
}

function configure(options) {
    options = Objutil.mixin(options, {
        freeDelay: 6 * 60 * 1000 // Free all memory after 6 min of inactivity
    });
    cache = RaptorCache.createMemoryCache(options);
}

function reset() {
    module.exports.configure();
}

module.exports.configure = configure;
module.exports.generateKey = generateKey;
module.exports.generateFooterKey = generateFooterKey;
module.exports.generateHeaderKey = generateHeaderKey;
module.exports.loadResource = loadResource;
module.exports.getResource = getResource;
module.exports.reset = reset;

Object.defineProperty(module.exports, 'cache', {
    get: function onCacheProp() {
        return cache;
    }
});

configure();
