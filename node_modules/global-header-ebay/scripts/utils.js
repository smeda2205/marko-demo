'use strict';

var Path = require('path');
var Fs = require('fs');
var Querystring = require('querystring');
var Httpunch = require('httpunch');
var Async = require('async');
var Objutil = require('objutil');

var Templify = require('../lib/templify');

var targetPath = Path.resolve(__dirname, '../resources');

if (!Fs.existsSync(targetPath)) {
    Fs.mkdirSync(targetPath);
}

function fetch(name, url, callback) {

    console.log('fetching %s with URL: %s', name, url);

    var retry = 1;

    load();

    function load() {
        Httpunch.get(url, function handleResponse(err, response) {
            if (err) {
                if (retry-- > 0) {
                    return load();
                }
                return callback(new Error('Failed to fetch ' + name + ' using URL: ' + url +
                    ' due to ' + err.stack));
            }

            if (response.statusCode >= 300 || response.statusCode <= 100) {
                return callback(new Error('Failed to fetch ' + name +
                    ' using URL: ' + url +
                    ', status code: ' + response.statusCod +
                    ', body: ', response.body.toString()));
            }

            callback(null, response.body);
        });
    }

}

function fetchAll(config, callback) {
    var _loadHeader = config.loadHeader || loadHeader;
    var _loadFooter = config.loadFooter || loadFooter;
    Async.series([
        fetchHeader.bind(null, config.variations, _loadHeader.bind(null, config.endpoints.header)),
        fetchFooter.bind(null, config.variations, _loadFooter.bind(null, config.endpoints.footer))
    ], callback);
}

function generateAllHeaderPermutations(config) {
    var variations = Objutil.mixin(config.header, config.common, {});
    return permutate(variations);
}

function fetchHeader(config, loadHeader, callback) {
    var permutations = generateAllHeaderPermutations(config);
    fetchContent(permutations, loadHeader, callback);
}

function generateAllFooterPermutations(config) {
    var variations = Objutil.mixin(config.footer, config.common, {});
    return permutate(variations);
}

function fetchFooter(config, loadFooter, callback) {
    var permutations = generateAllFooterPermutations(config);
    fetchContent(permutations, loadFooter, callback);
}

function fetchContent(permutations, load, callback) {
    var tasks = permutations.map(function createTask(options) {
        return load.bind(null, options);
    });

    Async.parallelLimit(tasks, 10, callback);
}

function permutate(variations) {
    var keys = Object.keys(variations);
    // generate initial permutation plan
    var plan = keys.reduce(function reduce(memo, key) {
        if (variations[key].length) {
            memo[key] = 0;
        }
        return memo;
    }, {});

    keys = Object.keys(plan);

    var permutations = [];
    var lastKey = keys[keys.length - 1];

    while(true) {
        var permutation = planToPermutation(plan, variations);
        permutations.push(permutation);

        // next plan
        for (var index = 0; index < keys.length; index++) {
            var key = keys[index];
            var nextKey = keys[index + 1];
            plan[key]++;
            if (plan[key] < variations[key].length) {
                break;
            }
            if (nextKey) {
                plan[key] = 0;
                continue;
            }
            break;
        }

        // should exit?
        if (plan[lastKey] === variations[lastKey].length) {
            break;
        }
    }

    return permutations;
}

function planToPermutation(plan, variations) {
    return Object.keys(plan).reduce(function reduce(memo, key) {
        var values = variations[key];
        var index = plan[key];
        memo[key] = values[index];
        return memo;
    }, {});
}

function loadHeader(url, options, callback) {
    var query = Querystring.stringify(options);
    var fetchUrl = url + (query ? '?' + query : '');
    var key = query.replace(/&/g, '__').replace(/=/g, '_');
    var fileName = 'header' + (key ? '_' + key : '') + '.json';
    var filePath = Path.resolve(targetPath, fileName);

    fetch('header', fetchUrl, function handleResponse(err, body) {
        if (err) {
            return callback(err);
        }
        // validate header content by rendering it
        var spec = JSON.parse(body.toString());
        Templify.header(spec.html, function handleValidation(err, template) {
            if (err) {
                return callback(err);
            }
            console.log('*** successfully validated header template');
            // store it
            Fs.writeFileSync(filePath, body);
            console.log('*** successfully stored header json at', filePath);

            callback();
        });
    });
}

function loadFooter(url, options, callback) {
    var query = Querystring.stringify(options);
    var fetchUrl = url + (query ? '?' + query : '');
    var key = query.replace(/&/g, '__').replace(/=/g, '_');
    var fileName = 'footer' + (key ? '_' + key : '') + '.json';
    var filePath = Path.resolve(targetPath, fileName);

    fetch('footer', fetchUrl, function handleResponse(err, body) {
        if (err) {
            return callback(err);
        }
        // validate
        var content = body.toString();
        JSON.parse(content);
        // store it
        Fs.writeFileSync(filePath, content);
        console.log('*** successfully stored footer html at', filePath);
        callback();
    });
}

module.exports.fetchAll = fetchAll;
module.exports.fetch = fetch;
module.exports.fetchHeader = fetchHeader;
module.exports.fetchFooter = fetchFooter;
module.exports.loadHeader = loadHeader;
module.exports.loadFooter = loadFooter;
module.exports.fetchContent = fetchContent;
module.exports.permutate = permutate;
module.exports.generateAllHeaderPermutations = generateAllHeaderPermutations;
module.exports.generateAllFooterPermutations = generateAllFooterPermutations;
