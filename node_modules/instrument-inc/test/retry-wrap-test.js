'use strict';

var assert = require('assert');

var _wrap = require('../lib/service-wrappers/retry');
var wrap = function () {
    return _wrap.apply(null, arguments).bind({});
};

describe(__filename, function () {

    var manager = {
        state: {
            checkMardownCounter: 0,
            service_state: 'MARK_UP'
        },
        isMarkdown: function isMarkdown() {
            this.state.checkMardownCounter++;
            return this.state.service_state !== 'MARK_UP';
        }
    };


    it('should not retry when there is no error', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            setImmediate(callback.bind(null, null, 'ok'));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 2
        }, function (err, result) {
            assert.ok(!err);
            assert.equal('ok', result);
            assert.equal(1, transportCounter);
            done();
        });
    });

    it('should retry 0 times for timeout error', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 0
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(1, transportCounter);
            done();
        });
    });

    it('should retry 0 times for timeout error when method is not idenpotent, even with non-zero retries', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 3,
            method: 'POST'
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(1, transportCounter);
            done();
        });
    });

    it('should retry 0 times for timeout error when method is idenpotent: GET, even with non-zero retries', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 3,
            method: 'GET'
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(4, transportCounter);
            done();
        });
    });

    it('should retry 0 times for timeout error when method is idenpotent: DELETE, even with non-zero retries', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 3,
            method: 'DELETE'
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(4, transportCounter);
            done();
        });
    });

    it('should retry 2 times for timeout error, default limit', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(1, transportCounter);
            done();
        });
    });

    it('should retry 2 times for timeout error', function (done) {
        var transportCounter = 0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 2
        }, function (err) {
            assert.ok(err);
            assert.equal('ETIMEDOUT', err.code);
            assert.equal(3, transportCounter);
            done();
        });
    });

    it('should not retry for other errors', function (done) {
        var transportCounter =0;
        function transport(options, callback) {
            transportCounter++;
            var err = new Error('Test error');
            setImmediate(callback.bind(null, err));
        }

        var wrapped = wrap(transport, manager);

        wrapped({
            retry: 2
        }, function (err) {
            assert.ok(err);
            assert.equal(1, transportCounter);
            done();
        });

    });

    it('should not share context between different calls to transports', function () {
        function transport(options, callback) {
            var err = new Error('Test error');
            setImmediate(callback.bind(null, err));
        }

        var wrapped1 = wrap(transport);
        var wrapped2 = wrap(transport);

        assert.ok(wrapped1 !== wrapped2);

    });

    it('should not share context between different calls to different transports', function (done) {
        var counter1 = 0;
        var counter2 = 0;
        function transport1(options, callback) {
            counter1++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }
        function transport2(options, callback) {
            counter2++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err));
        }

        var wrapped1 = wrap(transport1, manager);
        var wrapped2 = wrap(transport2, manager);

        assert.ok(wrapped1 !== wrapped2);

        wrapped1({
            retry: 1
        }, function () {
            wrapped2({
                retry: 2
            }, function () {
                assert.ok(counter2 !== counter1, 'Expected: ' + counter1 + ' is not equal to ' + counter2);
                done();
            });
        });
    });

    it('should not share context for the same wrapper', function (done) {
        var stats = {};
        function transport(options, callback) {
            stats[options.id] = stats[options.id] || 0;
            stats[options.id]++;
            var err = new Error('Test error');
            err.code = 'ETIMEDOUT';
            setImmediate(callback.bind(null, err, options));
        }

        var wrapped1 = wrap(transport, manager);
        var wrapped2 = wrap(transport, manager);

        var options1 = {
            id: 'A',
            retry: 1
        };
        wrapped1(options1, function () {
            var options2 = {
                id: 'B',
                retry: 2
            };
            wrapped2(options2, function () {
                assert.ok(stats.A !== stats.B,
                    'Expected: ' + stats.A + ' is not equal to ' + stats.B);
                done();
            });
        });

    });
});
