'use strict';

var assert = require('assert');
var async = require('async');
var shimmer = require('shimmer');
var debug = require('debug')('instrument-inc:asyncwrap');

module.exports.wrapFunc = function asyncwrap(original, before, after) {

    var wrapped = function wrapped() {
        var self = this;
        var args = Array.prototype.slice.call(arguments);

        var callback = args.pop();
        assert.ok(typeof callback === 'function', 'Callback is missing');

        // context to preserve between before and after
        var chain = [];

        // add after interceptor
        if (before) {
            chain.push(function _before(next) {
                debug(original.name, 'before');
                before.apply(self, args.concat(next));
            });
        }

        // main function
        chain.push(chain.length ? function _original() {
            original.apply(null, arguments);
        } : function (next) {
            original.apply(null, args.concat(next));
        });

        // execute
        async.waterfall(chain, function _after() {
            if (after) {
                debug(original.name, 'after');
                var cbArgs = Array.prototype.slice.call(arguments);
                after.apply(self, cbArgs.concat(callback));
            }
            else {
                callback.apply(null, arguments);
            }
        });
    };

    return function dispatch() {
        wrapped.apply(this, arguments);
        return wrapped;
    };
};

module.exports.wrap = function asyncwrap(obj, name, before, after) {

    shimmer.wrap(obj, name, function (original) {
        return function () {
            var self = this;
            var args = Array.prototype.slice.call(arguments);

            var callback = args.pop();
            assert.ok(typeof callback === 'function', 'Callback is missing');

            // context to preserve between before and after
            var ctx = {
                method: name,
                objRef: self
            };
            var chain = [];

            // add after interceptor
            if (before) {
                chain.push(function (next) {
                    before.apply(ctx, args.concat(next));
                });
            }

            // main function
            chain.push(chain.length ?
                function () {
                    original.apply(self, arguments);
                } :
                function (next) {
                    original.apply(self, args.concat(next));
                });

            // execute
            async.waterfall(chain, function (err, result) {
                var postFuncs = [];

                if (after) {
                    postFuncs.push(after);
                }

                if (postFuncs.length) {
                    var postExec = async.seq.apply(null, postFuncs);
                    postExec.call(ctx, err, result, callback);
                }
                else {
                    callback(err, result);
                }

            });
        };
    });

};
