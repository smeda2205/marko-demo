'use strict';

var util = require('util');
var urlUtils = require('url');
var objutil = require('objutil');

var asyncwrap = require('../asyncwrap').wrapFunc;
var logger = require('logging-inc').logger('instrument-inc/service-wrappers/retry');

module.exports = function retry(transport, manager) {

    var wrapped = asyncwrap(transport, function before(options, next) {

        if (!this.inited) {
            this.clientId = options.clientId;
            this.retry = isIdempotent(options.method || 'GET') || options['force-retry'] ? options.retry || 0 : 0;
            this.options = objutil.mixin(options, {});
            this.retryCounter = 0;
            this.inited = true;
        }

        next(null, options);

    }, function after(err, response, next) {

        var args = Array.prototype.slice.call(arguments);
        next = args.pop();
        err = args.shift();
        response = args.shift();

        if (err && err.code === 'ETIMEDOUT') {
            this.retryCounter = this.retryCounter || 0;
            if (this.retryCounter++ >= this.retry) {
                return next(err, response);
            }
            if (manager.isMarkdown(this.clientId)) {
                err = new Error('The service is being marked down with status APP_AUTO_MARK_DOWN' +
                                ', endpoint: ' +
                                util.format('%s%s%s', urlUtils.format(this.options),
                                    this.options.basehost || '',
                                    this.options.path || '') +
                                ', name: ' + this.clientId);
                err.code = 'APP_AUTO_MARK_DOWN';
                return next(err, response);
            }

            logger.warn('Timed out calling the service %s, will retry, current try: %d, limit: %d',
                this.clientId, (this.retryCounter-1), this.retry);

            // this wrapper reference does not have this, so we bind to this
            return wrapped.call(this, objutil.mixin(this.options, {}), next);
        }
        next(err, response);
    });

    return wrapped;
};

/**
 * check if the HTTP method is idempotent
 *
 * @param {string} methodName
 * @return {boolean}
 */
function isIdempotent(methodName) {
    return ['GET', 'PUT', 'HEAD', 'OPTIONS', 'DELETE'].indexOf(methodName.toUpperCase()) !== -1;
}
