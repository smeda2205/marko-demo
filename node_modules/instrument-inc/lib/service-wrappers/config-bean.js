'use strict';

var assert = require('assert');

var asyncwrap = require('../asyncwrap').wrapFunc;

var objutil = require('objutil');
var modConfig = require('module-config-inc');
var configbeans = require('module-config-inc/lib/configbeans');

function ConfigBeanWrapper(clientId, bean) {
    assert.ok(bean);
    this.clientId = clientId;
    this.bean = bean;
}

var proto = ConfigBeanWrapper.prototype;

proto.get = function get(name) {
    return this.bean.get(name);
};

proto.set = function set(name, value) {
    this.bean.set(name, value);
};

module.exports = function configBean(transport, manager) {

    return asyncwrap(transport, function before(options, next) {
        var clientId = options.clientId;

        modConfig(process.env.TEST_ROOT || manager.moduleRef, function(err, configObject) {
            var clientPath = 'services:'+clientId;
            var clientConfig = configObject.get(clientPath);
            assert.ok(clientConfig, 'Service config for client ' + clientId + ' is not found');

            var svcConfig = configObject.get(manager.moduleName) || {};
            clientConfig = objutil.merge(svcConfig, clientConfig);

            //If HTTPS flag is enabled, switch the protocol to HTTPS and set https=true for
            //HTTPS instrumentation to set the agent appropriately
            if(process.env.ENABLE_HTTPS === 'true' && (!clientConfig.protocol  || clientConfig.protocol === 'http:')) {
              clientConfig.protocol = options.protocol = 'https:';
              if(clientConfig.port === 80) {
                clientConfig.port = options.port = 443;
              }
              clientConfig.https = 'eBayRootCert';
            }

            var clientState = manager.getClientState(clientId);
            if (!clientState) {
                // inject config for client service
                var injectConfig = {
                    services: {},
                    '@ConfigBean': {}
                };

                // inject service status
                clientConfig.SVC_CHANNEL_STATUS = 'MARK_UP';
                // to control any debug instrumentation for service client calls
                clientConfig.debug = 'false';
                injectConfig.services[clientId] = injectConfig.services[clientId] || {};

                var beanDef = injectConfig['@ConfigBean'][manager.moduleName] =
                    injectConfig['@ConfigBean'][manager.moduleName] || {};

                var baseKey = 'services:'+clientId+':';

                var clientBeanDef = beanDef[clientId] = beanDef[clientId] || {};

                // cerate mapping to shorter name
                Object.keys(clientConfig).forEach(function forEach(key) {
                    clientBeanDef[baseKey + key] = key;
                });

                configObject.use(injectConfig);
                // create config bean
                var bean = configbeans.createConfigBean(manager.moduleName, configObject);
                configbeans.registerRaptorConfigs(manager.moduleName, configObject, bean);
                manager.addClientState(clientId, new ConfigBeanWrapper(clientId, bean[clientId]));
            }

            options = objutil.mixin(clientConfig, options, {});
            next(null, options);
        });

    });
};
