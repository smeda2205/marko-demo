'use strict';

var Assert = require('assert');
var Util = require('util');
var Objutil = require('objutil');

const PercentileBucket = require('./stats/PercentileBucket');
const CounterBucket = require('./stats/CounterBucket');
const RollingPercentile = require('./stats/RollingPercentile');
const RollingNumber = require('./stats/RollingNumber');

var debug = require('debug')('metrics-ebay/monitor');

/**
 * Create monitor.
 * @param options:
 *  - name - {string} specifies a name of the client to monitor; should be unique.
 *  - interval - publish interval, by default it will be 1 minute interval.
 *  - spec: {
 *      'metric name': 'aggregation operation: sum, avg, max, min'
 *    }
 *    if aggregation operation is missing then it will use 'sum' operation.
 * @param publishFn - function called by monitor that would format and publish corresponding metrics.
 *  By default it will publish metrics to process.emit('ebay:metrics-event', metrics-event).
 *  Metrics event structure
 *  {
 *      name: {given name},
 *      metrics: {
 *          foo: 322,
 *          bar: 33.
 *          ...
 *      }
 *  }
 *
 * @return a singleton Monitor instance
 */
exports.create = function create(options) {
    Assert.ok(options && typeof options === 'object', 'options are not provided');
    Assert.ok(options.name, 'name in options is missing');
    Assert.ok(options.spec && Object.keys(options.spec).length, 'spec in options is missing');

    return new Monitor(options);
};

function Monitor(options) {
    this._name = options.name;
    this._options = options || {};
    this.init();
    debug('new metrics %s created', this._name);
}

var proto = Monitor.prototype;
const OPERATIONS = ['inc', 'add', 'sum', 'min', 'max'];

proto.init = function init() {
    var spec = this._options.spec;

    debug('Monitor %s is initialized', this._name);
    this._metrics = Object.keys(spec).reduce(function reduce(memo, key) {
        // setup metric containor
        var mspec = spec[key];
        var operation = typeof mspec === 'string' ? mspec : mspec && mspec.operation || 'add';

        if (!mspec.ref && OPERATIONS.indexOf(operation) === -1) {
            throw new Error(Util.format('Unknown metric operation detected, client name %s, metric name %s, operation %s',
                this._name, key, operation));
        }

        memo[key] = new Metric({
            name: key,
            client: this._name,
            operation: mspec.ref ? undefined: operation,
            metric: mspec.metric,
            ref: mspec.ref,
            metrics: memo,
            windowLength: this._options.windowLength,
            numberOfBuckets: this._options.numberOfBuckets
        });

        return memo;
    }.bind(this), {});
};


class Metric {
    constructor(options) {
        this.options = options;
        if (this.options.ref) {
            return;
        }

        this.collector = options.operation === 'inc' ?
            new RollingNumber(options.windowLength, options.numberOfBuckets) :
            new RollingPercentile(options.windowLength, options.numberOfBuckets);
    }

    add(value) {
        if (this.options.ref) {
            throw new Error(`Attempt to update probe:${this.options.name} by ref:${this.options.ref}, client:${this.options.client}`);
        }
        if (this.options.operation === 'inc') {
            // name serves as a metrics name as collector hold values for all 'inc' metrics
            this.collector.increment();
        }
        else {
            this.collector.addValue(value);
        }
    }

    get(name) {
        name = name || this.options.metric;
        if (this.options.ref) {
            const refMetric = this.options.metrics[this.options.ref];
            Assert.ok(refMetric, `Cannot find probe:${this.options.name} by ref:${this.options.ref} for client:${this.options.client}, please chech the spec`);
            return refMetric.get(name);
        }
        if (this.collector instanceof RollingNumber) {
            return name === 'cumulative' ? this.collector.getCumulativeSum() : this.collector.getRollingSum();
        }
        Assert.ok(name, `Metric is undefined for probe:${this.options.name} for client:${this.options.client}`);
        return this.collector.getPercentile(name);
    }
}

/*
 *  update method updates value for the given metric.
*/
proto.update = function update(name, value) {
    var metric = this._metrics[name];
    Assert.ok(metric, Util.format('Unknown metrics name used, name: %s', name));
    metric.add(value);

    debug('Monitor %s has been updated:', this._name, metric);
};

/**
 * Return a metrics map of key-calue pairs, where key is a name of metric and value is accumulated value
*/
proto.getStats = function getStats(peek) {

    var metrics = Object.keys(this._metrics).reduce(function reduce(memo, key) {
        var metric = this._metrics[key];
        memo[key] = metric.get();
        return memo;
    }.bind(this), {});

    debug('metrics %s stats: %j', this._name, metrics);

    return metrics;
};
