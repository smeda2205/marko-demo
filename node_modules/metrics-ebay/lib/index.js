'use strict';

var Assert = require('assert');
var QueryString = require('querystring');

var Objutil = require('objutil');
var ValidateInternals = require('validate-internals-ebay');

var Monitor = require('./monitor');
var logger = require('logging-inc').logger('metrics-ebay/index');

var Formatters = require('./formatters');
var Specs = require('./specs');
var Utils = require('./utils');
var NodeUtil = require('util');

var debug = require('debug')('metrics-ebay/index');

var managers = {};

/**
 * Create a metrics set for the given name and spec with refresh interval.
 * @param options
 *   options.metadata is common metadata for the given metrics, like pool, operation, service name, etc.
 *   options.spec is a specification of metrics names and actions that needs to be performed on them
 *      spec.name - name of supported spec, currently it is only service-client
 *      spec.identity - provides identity infomration of what is being measured. For example .for service-client it would have
 *          identity.service - defines service attributes
 *          identity.operation - specifies operation
 *   options.format is a formatter function that applied on stats and options.
 *   options.interval is an interval between subsequent publishing for the given metrics set.
 *        If ommited, the publishing will be disabled.
*/
module.exports.create = function create(options) {
    Assert.ok(options, 'Options are missing');
    Assert.ok(options.spec, 'Spec name or function is missing (supported: rest)');

    options = Objutil.clone(options);

    var spec = Specs[options.spec];
    var name = Utils.generateName(options.identity, spec.identity);

    var manager = managers[name];
    if (manager) {
        debug('Found existing metrics monitor %s, stopped', name);
        // stop any previously started monitor for the given target
        manager.stop();
    }

    manager = managers[name] = this._createManager(name, options);

    manager.start();
    debug('Started metrics monitor %s, stopped', name);

    return manager.monitor;
};

module.exports.publishers = {
    cal: require('./publishers/cal')
};

module.exports._createManager = function _createManager(name, options) {
    var interval = options.interval;
    var publisher = options.publisher || 'cal';

    var format = Formatters[options.spec];
    if (!format) {
        throw new Error(NodeUtil.format('Formatter %s is not found', options.spec));
    }

    var spec = Specs[options.spec];
    if (!spec) {
        throw new Error(NodeUtil.format('Spec %s is not found', options.spec));
    }

    var monitor = Monitor.create(Object.assign({}, options, {
        name: name,
        spec: spec.metrics
    }));

    debug('registering metrics component status, name:', name);
    ValidateInternals.register(name, function componentStatus() {
        var statsData = monitor.getStats(true);
        var formattedData = format.vi(statsData);

        return {
            name: name,
            alias: name,
            properties: Object.keys(formattedData).reduce(function reduce(memo, key) {
                memo.push({
                    name: key,
                    value: formattedData[key]
                });
                return memo;
            }, [])
        };
    });

    return {
        monitor: monitor,

        stop: function stop() {
            if (this.timer) {
                debug('Metrics stopped:', name);
                clearInterval(this.timer);
                this.timer = undefined;
            }
        },

        start: function start() {

            if (!interval) {
                debug('Metrics %s was not started due to missing interval:', name);
                return;
            }

            if (interval < 1000) {
                logger.warn('You set too small publish interval for metrics name: %s',
                    name, new Error('Too small refresh interval'));
            }

            debug('Metrics started:', name);
            this.timer = setInterval(function publish() {
                if (!this.timer) {
                    return;
                }

                var statsData = this.monitor.getStats();
                statsData.options = options;
                var statsEvent = format(statsData, options);

                debug('Metrics %s published:', name, statsEvent);
                process.emit('metrics-stats:' + publisher,
                    statsEvent);
            }.bind(this), interval);
            this.timer.unref(); // to allow process exit
        }
    };
};

module.exports.stop = function stop() {
    Object.keys(managers).forEach(function forEach(key) {
        managers[key].stop();
    });

    managers = {};
};
