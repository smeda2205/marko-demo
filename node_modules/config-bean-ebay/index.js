'use strict';

var path = require('path'),
    util = require('util'),
    _ = require('underscore'),
    fs = require('graceful-fs'),
    lockfile = require('lockfile'),
    flatten = require('flat'),
    utils = require('./lib/utils'),
    EventEmitter = require('events').EventEmitter,
    debug = require('debug')('config-bean:index');

var configbeanIDs = {}, // List of defined bean id's
    fileWatchList = {},
    syncedWithDisk, // used to force load of all on disk beans when starting
    BEAN_DIR = path.resolve(process.cwd(), '.beans'),
    LOCKFILE_DIR = path.resolve(BEAN_DIR, '__lockfile');

var CONS = {
    delimiter: '___',
    beanGroup: 'nodejs.config',
    beanIdPrefix: 'nodejs.config.'
};

function createBeanDirs() {
    try {
        if (!fs.existsSync(BEAN_DIR)) {
            fs.mkdirSync(BEAN_DIR);
        }
    } catch (e) {
        //No Op
    }
    try {
        if (!fs.existsSync(LOCKFILE_DIR)) {
            fs.mkdirSync(LOCKFILE_DIR);
        }
    } catch (e) {
        //No Op
    }
}
//Create dirs on init
createBeanDirs();

// This holds each config bean constructed by ConfigBeanAdaptor and is
// basis for eventing the bean creator of changes.
var savedConfigBeans = {};

/*
 * Constructor for a config bean object. Values making up the bean
 * are passed in. If the bean is later changed by the set method,
 * a 'changed' event will be emitted after 5sec
*/
var ConfigBeanAdaptor = module.exports.ConfigBeanAdaptor = function ConfigBeanAdaptor(configbean) {
    this.configbean = configbean;
    this.eventTimer;

    EventEmitter.call(this);
    savedConfigBeans[configbean.id] = this;
    // At first use of any ConfigBean by an instance, force the instance
    // to pick up any disk-based beans it has never seen before (e.g at
    // application restart for example).
    if (!syncedWithDisk) {
        syncWithDiskBeans();
        syncedWithDisk = 1;
    }

    /*
     * changeEvent after delay (5 sec) to avoid unnecessary multiple events,
     * in case of bulk sets
     */
    this.fireChangeEvent = function () {
        if (this.eventTimer) {
            clearTimeout(this.eventTimer);
        }
        this.eventTimer = setTimeout(function () {
            this.emit('changed');
        }.bind(this), 5000);
    };

    /*
     * get returns bean property value by name
     * @name {string} - property name
    */
    this.get = function get(name) {
        name = name.replace(/:/g, CONS.delimiter);
        var val = getConfigBeanValue(this.configbean, name);
        return val;
    };

    this.lastUpdated = function lastUpdated(name) {
        if (!name) {
            return this.configbean.lastUpdated || this.configbean.created;
        }
        name = name.replace(/:/g, CONS.delimiter);
        return getLastUpdated(this.configbean, name);
    };

    /*
     * getAttributes returns an array of all the attributes of the bean.
    */
    this.getAttributes = function getAttributes(modified) {
        var attrs = [];
        var attribs = _.clone(this.configbean.attributes);
        attribs.forEach(function (elt) {
            if (modified === true && !elt.lastUpdated) {
                return;
            }
            elt = _.clone(elt);
            if (elt.value === '') {
                elt.value = elt.defaultValue;
            }
            attrs.push(elt);
        });
        return attrs;
    };

    this.getConfig = function getConfig() {
        var attributes = this.getAttributes();
        var config = {};
        attributes.forEach(function (attr) {
            if (attr.name.indexOf(CONS.delimiter) !== -1) {
                var attrParts = attr.name.split(CONS.delimiter);
                var localConfig = config;
                var keyPath = '';
                for (var i = 0; i < attrParts.length; i++) {
                    if (i > 0) {
                        keyPath += ':';
                    }
                    keyPath += attrParts[i];
                    if (this.get(keyPath) !== undefined) {
                        localConfig[attrParts[i]] = this.get(keyPath);
                    } else {
                        localConfig[attrParts[i]] = localConfig[attrParts[i]] || {};
                        localConfig = localConfig[attrParts[i]];
                    }
                }
            } else {
                config[attr.name] = this.get(attr.name);
            }
        }.bind(this));
        return config;
    };

    /**
     * The method sets the bean property by name.
     * @name {string} is property name
     * @value is property value
     * Returns previous value. If the value could not be set,
     * an Error object is returned and no change event is fired.
    */
    this.set = function set(name, value) {
        name = name.replace(/:/g, CONS.delimiter);
        // If name is an attribute holding an array, and the value is
        // not an array (e.g. likely a string from ValidateInternals),
        // convert the string form to an array before storing it.

        const attr = findByName(this.configbean, name);
        const parsedValue = utils.tryParseValue(value, attr && attr.type);
        if (parsedValue instanceof Error) {
            return parsedValue;
        }

        var oldValue = this.get(name);
        if (parsedValue.value === undefined || _.isEqual(oldValue, parsedValue.value)) {
            return oldValue;
        }
        value = setConfigBeanValue(this.configbean,
            name, parsedValue,
            parsedValue.type === 'timestamp'); // should always persist timestamp
        if (value instanceof Error) {
            return value;
        }
        this.fireChangeEvent();
        return oldValue;
    };

    /**
     * The method sets the bean property by name such that it will
     * override local bean property settings.
     * @name {string} is property name
     * @value is property value
     * Returns previous value. If the value could not be set,
     * an Error object is returned.
    */
    this.setPersist = function setPersist(name, value) {
        var oldValue = this.get(name);
        if (value === undefined || _.isEqual(oldValue, value)) {
            return oldValue;
        }
        oldValue = setConfigBeanValue(this.configbean, name, value, true);
        this.fireChangeEvent();
        return oldValue;
    };

    this.reset = function reset() {
        this.configbean = resetToDefault(this.configbean);
        this.fireChangeEvent();
        return this.configbean;
    };
};

util.inherits(ConfigBeanAdaptor, EventEmitter);

// Get a bean object using its id
module.exports.getBeanById = function getBeanById(id) {
    if (savedConfigBeans[id]) {
        return savedConfigBeans[id];
    } else {
        if (isBeanOnDisk(id)) {
            var bean = loadBeanData(id);
            var newBean = new ConfigBeanAdaptor(bean);
            return newBean;
        }
    }
};

// Returns a list of the names of all known config beans and syncs disk
module.exports.getConfigBeanList = function getConfigBeanList() {
    syncWithDiskBeans();
    return Object.keys(savedConfigBeans);
};

module.exports.getConfigBeans = function getConfigBeans(modified) {
    syncWithDiskBeans();
    return Object.keys(savedConfigBeans).reduce((memo, id) => {
        const bean = savedConfigBeans[id];
        if (!modified || bean.configbean.lastUpdated) {
            memo.push(bean);
        }
        return memo;
    }, []);
};

// Forces all disk config beans to be loaded into memory. Someone else
// may have created one and if our instance has never used it, there
// will be no file watching going on.
module.exports.syncDiskBeans = function syncDiskBeans() {
    syncWithDiskBeans();
};

// Returns all config data (not actual beans) in the form:
// {group1: [{id:name1}, {id:name2},...], group2: [{id:name1},...]}
// The elements of the arrays holding id's are sorted by name values.
// Only used for VI view by group page

module.exports.getConfigBeansGrouped = function getConfigBeansGrouped() {
    var group = {};
    Object.keys(savedConfigBeans).forEach(function (elt) {
        var beanData = savedConfigBeans[elt].configbean;
        if (!group[beanData.group]) {
            group[beanData.group] = [beanData.id];
        } else {
            group[beanData.group].push(beanData.id);

        }
    });
    // Order the group elements
    Object.keys(group).forEach(function (gname) {
        group[gname] = group[gname].sort();
    });
    return group;
};

// Define a config bean. Creates and returns a config bean object.
// These are classic eBay Java-like config beans. See defineConfig
// for registering config info as a bean-like object.
module.exports.define = function define(def) {

    var bean = def;
    def.configbean = true;
    bean.alias = bean.alias ? bean.alias : 'nodejs.ebay.configBean';
    bean.group = bean.group ? bean.group : 'nodejs.ebay';
    bean.created = Date.now();

    var attrList = [];
    if (def.attributes) {
        //_.each(_.keys(def.attributes), function (attrName) {
        Object.keys(def.attributes).forEach(function (attrName) {
            const attr = def.attributes[attrName];
            const value = attr.type ?
                (attr.defaultValue !== undefined ? attr.defaultValue : attr.value) :
                attr.value;
            const parsedValue = utils.parseValue(value, attr.type);
            attrList.push({
                name: attr.name || attrName,
                desc: attr.desc,
                type: parsedValue.type,
                value:  '',
                defaultValue: parsedValue.value !== undefined ? parsedValue.value : '',
                readable: typeof attr.readable !== 'undefined' ? attr.readable : true,
                writable: typeof attr.writable !== 'undefined' ? attr.writable : true
            });
        });
        bean.attributes = attrList;
    }

    if (configbeanIDs[def.id]) {
        throw new Error('The config bean with this id has already been defined, id: ' + def.id);
    }
    configbeanIDs[def.id] = true;

    // Never defined in this worker. See if it is on disk. If so, use the value from
    // disk rather than the initial default one.
    var reload = true;
    if (isBeanOnDisk(bean.id)) {
        reload = false;
    }
    var newBean = new ConfigBeanAdaptor(bean);
    savedConfigBeans[def.id] = newBean;
    manageFileVersion(bean, reload);

    return newBean;
};


// Define a config bean using a module-config style set of properties.
// This allows module-config to register configurations as config beans
// that can be viewed and updated using ValidateInternals.
module.exports.defineConfig = function defineConfig(config, id) {

    // Use . separator so ValidateInternals attribute editing screen is happy
    var flatted = flatten(config, {delimiter: CONS.delimiter, 'safe': true});
    var bean = {};
    bean.id = CONS.beanIdPrefix + id;
    bean.configbean = true;
    bean.alias = bean.id;
    bean.group = CONS.beanGroup;
    bean.created = Date.now();

    var attrList = [];
    Object.keys(flatted).forEach(function (key) {
        const parsedValue = utils.parseValue(flatted[key]);
        attrList.push({
            name: key,
            value: '',
            defaultValue: parsedValue.value,
            type: parsedValue.type,
            readable: true,
            writable: true
        });
    });
    bean.attributes = attrList;

    if (configbeanIDs[bean.id]) {
        throw new Error('The config bean with this id has already been defined, id: ' + bean.id);
    }
    configbeanIDs[BEAN_DIR.id] = true;

    // Never defined in this worker. See if it is on disk. If so, use the value from
    // disk rather than the initial default one.
    var reload = true;
    if (isBeanOnDisk(bean.id)) {
        reload = false;
    }
    var newBean = new ConfigBeanAdaptor(bean);
    savedConfigBeans[bean.id] = newBean;
    manageFileVersion(bean, reload);

    return newBean;
};


// helper methods
function findByName(configbean, name) {
    name = name.replace(/:/g, CONS.delimiter);
    return _.find(configbean.attributes, function (elem) {
        return _.isEqual(elem.name, name);
    });
}

// Returns attr.value unless it is empty and then it
// returns attr.defaultValue.
function getConfigBeanValue(configbean, name) {
    var attr = findByName(configbean, name);
    if (attr) {
        var val;
        if (attr.value || attr.value === false || attr.value === 0) {
            val = attr.value;
        } else {
            val = attr.defaultValue;
        }

        if (typeof val === 'string') {
            switch(attr.type) {
                case 'integer':
                    return Number(val);
                case 'boolean':
                    return val === 'true';
            }
        }
        return val;
    }
}

function getLastUpdated(configbean, name) {
    var attr = findByName(configbean, name);
    return attr && attr.lastUpdated || configbean.created;
}

function setConfigBeanValue(configbean, name, value, persist) {
    var val;
    // If being set by remote config (persist=true), put the value
    // in "defaultValue" and make "value" empty. This allows local
    // override by ValidateInternals for testing but allows
    // restoring the global setting later.
    if (persist) {
        var attr = findByName(configbean, name);
        var defaultVal = attr && attr.defaultValue;
        // If defaultValue is unchanged, don't wipe out value as user may
        // be using VI to test things on the box. Change to raptorConfig
        // value will override the locally set VI value.
        if (_.isEqual(value, defaultVal)) {
            return attr.value;
        }
        val = setConfigBeanProp(configbean, name, 'defaultValue', value, true);
        if (val instanceof Error) {
            return val;
        }
        val = setConfigBeanProp(configbean, name, 'value', '', true);
    } else {
        val = setConfigBeanProp(configbean, name, 'value', value);
        if (val instanceof Error) {
            return val;
        }
        configbean.lastUpdated = Date.now();
    }
    var bean = manageFileVersion(configbean, true); // true parameter marks changed bean; re-persist
    savedConfigBeans[configbean.id].configbean = bean;
}

function setConfigBeanProp(configbean, name, attrName, value, persist) {
    var err;

    if (typeof value === 'undefined') {
        return;
    }

    var attr = findByName(configbean, name);
    const parsedValue = value instanceof utils.ParsedValue ?
        value : utils.tryParseValue(value, attr && attr.type);

    if (parsedValue instanceof Error) {
        return parsedValue;
    }

    const theType = parsedValue.type;
    value = parsedValue.value;
    if (attr) {
        if (!attr.writable) {
            err = 'The property is not writable, propname: ' + name + ', config bean id: ' + configbean.id;
            debug(err);
            return new Error(err);
        }

        // Only type-check the value property
        if (attrName === 'value') {
            // If value is an array, be sure we aren't setting it to a scalar
            if (Array.isArray(value)) {
                if (attr.value !== '' && !(utils.isArray(attr.value) && utils.isArray(attr.defaultValue))) {
                    err = 'The value being set for propname: ' + name +
                    ', config bean id: ' + configbean.id +
                    ' is an array but a scalar is expected ';
                    debug(err);
                    return new Error(err);
                }
            } else {
                if (utils.isArray(attr.value) || utils.isArray(attr.defaultValue)) {
                    err = 'The value being set for propname: ' + name +
                    ', config bean id: ' + configbean.id + ' is not an array. Value is ' + value;
                    debug(err);
                    return new Error(err);
                }
                if (theType !== attr.type && value !== '') {
                    err = 'The value being set for propname: ' + name +
                    ', config bean id: ' + configbean.id + ' is not of type ' +
                    attr.type + '. Value is ' + value;
                    debug(err);
                    return new Error(err);
                }
            }

            if (value !== '' && !persist) {
                attr.lastUpdated = Date.now();
            }
        }
        var oldVal = attr[attrName];
        attr[attrName] = value;
        return oldVal;
    }

    // Create new property
    var prop = {
        'name': name,
        'value': '',
        'defaultValue': value,
        'type': theType,
        'readable': true,
        'writable': true,
        lastUpdated: Date.now(),
        isNew: true
    };

    configbean.attributes.push(prop);

    return null;
}

// Reset value to those of the initial default when created or
// to the value set globally by remote config.
// Empty string in value property causes value from defaultValue to
// be used. This comes from the initial value or the global setting.
function resetToDefault(configbean) {
    configbean.attributes = configbean.attributes.reduce(function (memo, attr) {
        attr.value = '';
        delete attr.lastUpdated;
        if (!attr.isNew) {
            memo.push(attr);
        }
        return memo;
    }, []);
    delete configbean.lastUpdated;

    // true parameter marks changed bean; re-persist
    configbean = manageFileVersion(configbean, true);
    return configbean;
}

function isBeanOnDisk(id) {
    var beanPersistPath = getBeanPersistPath(id);
    return fs.existsSync(beanPersistPath);
}

/*
 * The method read/writes config bean info on disk.
 * If config bean data is not on disk, it is written there.
 * If it is already there, it is rewritten.
 * If it exists on disk, the data is read into configBean.
 * A file watcher is established to detect writes to the persisted
 * bean. If detected, the bean is reloaded from disk.
 * @configBean - configBean object
 * returns original bean or updated version
*/
function manageFileVersion(configbean, changed) {
    var configbeanPersistPath = getBeanPersistPath(configbean.id);

    // If new bean (not on disk), write a copy there and watch it.
    if (!fs.existsSync(configbeanPersistPath)) {
        //persist configbean
        debug('persisted: ', configbean.id, ' group: ', configbean.group, ' managed: ', configbeanPersistPath);
        writeWithLock(configbeanPersistPath, configbean);
        setWatchFile(configbeanPersistPath, configbean);
        return configbean;
    }
    // If not changed and exists on disk, read up a copy. Still need a watch
    // setup as this is being called on definition path.
    else if (!changed) {
        //read from persisted
        configbean = loadBeanData(configbean.id);
        return configbean;
    }

    // If on disk, update what is there. This will trigger a change event
    // from the earlier watch.
    writeWithLock(configbeanPersistPath, configbean);
    setWatchFile(configbeanPersistPath, configbean);
    debug('persisted: ', configbean.id, ' group: ', configbean.group, ' managed: ', configbeanPersistPath, ' updates: ', configbean);
    return configbean;
}

function getBeanPersistPath(id) {
    return path.join(BEAN_DIR, encodeURIComponent(id) + '.configbean');
}

function loadBeanData(id) {
    var beanData,
        configbeanPersistPath = getBeanPersistPath(id);

    if (configbeanPersistPath && fs.existsSync(configbeanPersistPath)) {
        try {
            beanData = JSON.parse(fs.readFileSync(configbeanPersistPath));
            if (!savedConfigBeans[beanData.id]) {
                savedConfigBeans[beanData.id] = new ConfigBeanAdaptor(beanData);
            }
            savedConfigBeans[beanData.id].configbean = beanData;
            debug('loaded: ', beanData.id, ' group: ', beanData.group, ' managed: ', configbeanPersistPath, ' of: ', beanData);
            setWatchFile(configbeanPersistPath, beanData);
        } catch (e) {
            debug(e);
        }
    }

    return beanData;
}

function writeWithLock(dirPath, configbean) {
    // lock is per config bean being written.
    var lockfilePath = path.resolve(LOCKFILE_DIR, '_' + configbean.id.replace(/[^a-zA-Z0-9.-]/g, '_'));
    // Get the lock with retries.
    try {
        lockfile.lockSync(lockfilePath, {retries: 5});
        var tmpFile = dirPath + '.' + process.pid + '.tmp';
        fs.writeFileSync(tmpFile, JSON.stringify(configbean, null, 2));
        fs.renameSync(tmpFile, dirPath);
    } catch (e) {
        //No Op
        console.log('Failed to write config bean due to', e);
    }
    lockfile.unlockSync(lockfilePath);
}

function setWatchFile(dirPath, bean) {
    // watch for any writes to the persisted configbean and reload
    // but don't watch multiple times
    if (!fileWatchList[dirPath] && bean) {
        fileWatchList[dirPath] = 1;
        fs.watchFile(dirPath, {'persistent': true}, function fileChanged(curr, prev) {
            if (curr.mtime !== prev.mtime && fs.existsSync(dirPath)) {
                let lastUpdated;
                if (bean && bean.id) {
                    lastUpdated = bean.lastUpdated;
                    bean = loadBeanData(bean.id);
                }
                if (bean && bean.id) {
                    debug('reloaded: ', bean.id, ' group: ', bean.group, ' managed: ', dirPath, ' of: ', bean);
                    var emitBean = savedConfigBeans[bean.id];
                    if (emitBean && lastUpdated !== bean.lastUpdated) {
                        emitBean.emit('changed');
                    }
                }
            }
        });
    }
}

// Update memory info if there are beans we don't know about on disk
function syncWithDiskBeans() {
    var files = fs.readdirSync(BEAN_DIR);
    for (var i = 0; i < files.length; i++) {
        if (path.extname(files[i]) === '.configbean') {
            var base = decodeURIComponent(path.basename(files[i], '.configbean'));
            if (!savedConfigBeans[base]) {
                loadBeanData(base);
            }

        }
    }
}
