#config-bean-ebay 
[![Build Status](https://ebayci.qa.ebay.com/CI-Instance/buildStatus/icon?job=config-bean-ebay)](https://ebayci.qa.ebay.com/CI-Instance/job/config-bean-ebay) [![Dependency Status](https://nodevalid-i3ey5.vip.lvs01.dev.ebayc3.com/nodejs/config-bean-ebay.svg)](https://nodevalid-i3ey5.vip.lvs01.dev.ebayc3.com/nodejs/config-bean-ebay)  [![Code Coverage](https://nodevalid-i3ey5.vip.lvs01.dev.ebayc3.com/coverage/nodejs/config-bean-ebay)](http://sonar/dashboard/index?id=config-bean-ebay)




Create/manage config bean.

Config beans are a mechanism at eBay for seeing and manipulating properties
of an application or service. See [ValidateInternals](https://github.corp.ebay.com/nodejs/validate-internals-ebay) for details on the commands to see
and manipulate config beans via a URL.
This module allows your application to create config beans. Often, it will be easier
to just have config/config.json data for your application as you can integrate this
with config beans and with centrally manageable raptor-config.  Those modules work
with this one to provide externally viewable and modifiable configurations.

## Changelog

See   [CHANGELOG.MD](https://github.corp.ebay.com/nodejs/config-bean-ebay/blob/master/CHANGELOG.md#changelog)

# Installation

```
npm install config-bean-ebay --save
```

# Usage

Typically a module or an application will initially define a config bean
to describe its externally visible and modifiable properties. Once
defined, the config bean's properties can be read or set by the API and
are visible via a ValidateInternals URL.


# API

## Defining a config bean

The config bean is defined by supplying an object to the define
method. For example, the following defines the bean that controls
whether a machine is taking traffic or not.

```javascript
var trafficEnabler = {
    'configbean': true,
    'id': 'ebay.kernel.ServeTraffic',
    'alias': 'ebay.kernel.ecv',
    'group': 'ebay.kernel',
    'desc': 'Serve Traffic to this server.',
    'attributes': [{
        'name': 'TrafficAttr',
        'value': 'TrafficEnabled',
        'desc': 'Serve Traffic to this server.',
        'type': 'string',
        'readable': 'true',
        'writable': 'true'
    }]
};

var configBean = require('config-bean-ebay');
var trafficBean = configBean.define(trafficEnabler);
```
The define method returns a config bean object that
supports a get, set and clear method. The bean also
emits a 'changed' event if you want to monitor and
react to changes of values in the bean by api or via
an external agency like ValidateInternals.

## Get an existing config bean

```javascript
var cfgBean = require('config-bean-ebay').getBeanById(beanId);
```

For config beans created by module-config-inc, the id name is of the form
`nodejs.config.theBeanName`.

## Get a config bean property

Using the trafficBean defined above this will retrieve the value property.

```javascript
var currentValue = trafficBean.get('TrafficAttr');
```

## Set a config bean property

Using the trafficBean defined above this will change the value property.
This should not generally be used programmatically from your application.
It is for testing and for ValidateInternals to update individual settings
via web interface. It causes the bean to be updated on disk so high
volume usage is not a good idea.

```javascript
var oldValue = trafficBean.set('TrafficAttr', 'TrafficDisabled');
```

## Set a config bean property and persist

This is similar to the set method but the value is "permanent".
This is used for values that are set via remote config to apply
to all machines.  By default, this is value that will be returned
if it has been set by remote config. It can only be changed by
remote config modification. Using ValidateInternals, this value
can be temporarily overridden for a box (e.g. for testing behavior
for a box that is out of traffic). The oldValue returned is
whatever the getMethod would have returned prior to the call.

```javascript
var oldValue = experimentBean.setPersist('holidayMode', 'enabled');
```

## Get config bean attributes

Get an array of all the attributes of the config bean

```javascript
var attrs = trafficBean.getAttributes();
```

## Get config bean as json

Get an json object of the config bean

```javascript
var attrs = trafficBean.getConfig();
```

## Reset a config bean

The reset method allows you to reset the config bean values to
the state at the time of definition and returns a bean reflecting that.
This would not normally be a programmatic usage except by ValidateInternals
which exposes a way for a user to reset a config bean after making some
changes. A reset causes a 'change' event to be emitted.

```javascript
var defaultBean = trafficBean.reset();
```

## Ensure all defined beans are loaded

In a multiple clustered node application, it is possible that one instance
has created a config bean and the other instances are not aware of it.
There is a copy on disk but they do not have a file watch event on it
to detect changes. If you really need to be sure all defined beans are
loaded up and have file watches setup, use this:

```
configBean.syncDiskBeans();
```

At first use of a config bean by an instance, all beans will be synched
for you but you can also force this if you need to .

## Defining a module-config bean

The above methods relate to the classic eBay config bean used by the
Java architecture. The node framework allows apps and modules to
define their own configs using module-config. Kraken provides a
confit module that is the underpinning of the config mechanism.

In order to extend, the abilities of config beans to config properties
coming from module-config, a second defineConfig method is provided.

```javascript
var cfg = {
      "i18n": {
            "contentPath": "./locales",
            "fallback": "en-US"
        },

        "services": {
            "servicecore": {
                "rejectUnauthorized" : false
            }
        },
        "array": ['a', 'b', 'c'],
        "int": 123
};
var configBean = require('config-bean-ebay');
var beanId = 'monitor-inc';
var bean = configBean.defineConfig(cfg, beanId);
```

Like the earlier define method, defineConfig creates a config bean and
returns it for the definer to use. Some conventions are applied
since module config data does not have all the information a classic
config bean is expected to have and we want these to be available
to existing tools like ValidateInternals. Therefore, the following
are defined by convention:
 * bean id: nodejs.config. + beanId passed in the definition
 * bean alias: same as bean id
 * bean group: nodejs.config
 * bean desc: empty
 * attributes: derived from the cfg object passed to defineConfig

 Since existing tools assume a flat name-value form for config
 bean properties, we must map the nested configs to this form.
 They are flattened to one dot-separated name per value. Using
 the above example, the resulting bean properties would be:

```javascript
i18n.contentPath = "./locales"
i18n.fallback = "en-US"

services.servicecore.rejectUnauthorized = false

array = ['a', 'b', 'c']
int = 123
```

Note that an array value is retained as an array and are modified
as an array of values. If yoiu use arrays in
your config, they should be terminal elements in the config. Things like
arrays of arrays are not supported.

Types are inferred from the value: boolean, integer and string
can be detected.

Using ValidateInternals a property like i18n fallback could be changed using:

```
host:8080//admin/v3console/UpdateConfigCategoryXml?id=nodejs.config.monitor-inc&i18n.fallback=de-DE
```

or it can be changed using the web-based editing mechanism by clicking on
the value shown when viewing the config bean, editing the value, hit return
and then submit via the button at the bottom of the page.

# Advanced

## Consistency among workers in a cluster

In a clustered configuration, multiple worker instances of the same app can handle
ValidateInternal requests. Config beans are stored on disk and this is the unit
of sharing between the workers.  Here are the interesting use cases that need to
be handled by this module regarding the interaction of two independent workers.

Use Cases:
Worker 1 asked to define a bean.
Worker 1 actions: If bean is not on disk, add bean info to memory cache and then
write the bean to disk and establish a file watch on the file.
Worker 2 knows nothing of this as it is not involved yet and knows nothing of
this bean.

Worker 1 asked to read bean via VI (or code API).
Worker 1 actions: If in cache, get value from there. Cache should be current as the watch
file would have emitted a change event if anyone else updated the bean.
If not in cache, try to load from disk and add to cache if found. Then
set a watch on the file as Worker 1 is now aware of the bean. If not on
disk, report no such bean.

Worker 1 asked to update Config by VI (or code API)
Worker 1 actions: If in cache, update cache and write new bean to disk
Fire a changed event to local listeners.
Worker 2 actions: File watch will fire and worker 2 will read the changed
bean, update the cached copy. If worker 2 is not aware of this bean, nothing happens.
If bean not in Worker 1 cache, load it from disk and add changed to cache. Write the updated
bean to disk and watch the disk file. This will notify any other worker that is
watching the bean.  If not in cache and not on disk, report error.
Worker 2 will receive a watch event if watching the bean file and will update its
cached copy and notify local listeners of the change. If not watching the bean,
then nothing happens.

Worker 1 asked for ViewConfigCategoryList or RenderServiceComponents.
Worker 1 reads directory holding beans and gets a list of all xxx.configbean files.
For each not in cache, read it and add it to cache. Set a watch on each new
bean added.

See [module-config-inc](https://github.corp.ebay.com/nodejs/module-config-inc) for
more details on defining config beans via config.json files and
managing these via raptor-config.
