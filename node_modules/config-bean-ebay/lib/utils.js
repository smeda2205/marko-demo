'use strict';

const Assert = require('assert');

const regExpType = /^(timestamp|string|array|integer|boolean):(.+)/;

const TYPE_PARSERS = {
    timestamp(str) {
        if (/now/i.test(str)) {
            return Date.now();
        }
        if (!str) {
            return '';
        }
        if (/^\d+$/.test(str)) {
            return parseInt(str);
        }
        throw new Error(`Improper value format for timestamp, value: "${str}"`);
    },

    array(str) {
        if (Array.isArray(str)) {
            return str;
        }

        if (isArray(str)) {
            return JSON.parse(str);
        }
        throw new Error(`Improper value format for array, value: "${str}"`);
    },

    integer(str) {
        if (typeof str === 'number') {
            return str;
        }
        if (/^\d+$/.test(str)) {
            return parseInt(str);
        }
        if (str === '' || str === undefined || str === null) {
            return '';
        }
        throw new Error(`Improper value format for integer, value: "${str}"`);
    },

    boolean(str) {
        if (str === 'true' || str === true) {
            return true;
        }
        if (str === 'false' || str === false) {
            return false;
        }
        throw new Error(`Improper value format for boolean, value: "${str}"`);
    },

    string(str) {
        if (str === null || str === undefined) {
            return '';
        }
        if (typeof str === 'string') {
            return str;
        }
        throw new Error(`Improper value format for string, value: "${str}"`);
    },

    object(str) {
        if (str instanceof Error) {
            return str.stack;
        }
        try {
            return typeof str === 'string' ? JSON.parse(str) : str;
        }
        catch (err) {
            throw new Error(`Melformed object "${str}", parse error ${err.message}`);
        }
    }
};

class ParsedValue {
    constructor(type, value) {
        this.type = type;
        this.value = adjustValue(value, type);
    }
}

// Check if the supplied param is an array or can be parsed into
// an array by JSON.parse.
function isArray(val) {
    var parsed;

    if (Array.isArray(val)) {
        return true;
    }
    try {
        parsed = typeof val === 'string' && val.indexOf('[') !== -1 ? JSON.parse(val) : parsed;
    } catch (e) {

    }
    return Array.isArray(parsed);
}

function parseValue(str, expectedType) {
    const givenTypeMatch = str &&
        typeof str === 'string' &&
        str.match(regExpType);

    if (givenTypeMatch) {
        const type = givenTypeMatch[1];
        return new ParsedValue(type, givenTypeMatch[2]);
    }

    if (expectedType) {
        return new ParsedValue(expectedType, str);
    }

    const type = getType(str, expectedType);
    return new ParsedValue(type, str);
}

function tryParseValue(str, expectedType) {
    try {
        return parseValue(str, expectedType);
    } catch (e) {
        return e;
    }
}

function adjustValue(value, type) {
    if (!type) {
        type = getType(value);
    }
    const parse = TYPE_PARSERS[type] || TYPE_PARSERS[getType(value)];
    Assert.ok(parse, `Cannot find parse for given type: ${type}, value: ${value}`);
    return parse(value);
}

// Try to guess type of property value for bean attribute type
// No attempt to handle Date or float
function getType(str, expectedType) {
    if (isArray(str)) {
        return 'array';
    }
    else if (typeof str === 'boolean' || str === true || str === false) {
        return 'boolean';
    // ValidateInternals UpdateConfig shows true/false as string.
    // Avoid a type mismatch error if boolean is expected and we get string form
    } else if ((str === 'true' || str === 'false') && (!expectedType || expectedType === 'boolean')) {
        return 'boolean';
    } else if (!isNaN(str) && !isNaN(parseInt(str))) {
        return 'integer';
    } else if (isObject(str)) {
        return 'object';
    } else {
        return 'string';
    }
}

function isObject(str) {
    if (typeof str === 'string') {
        try {
            str = JSON.parse(str);
        }
        catch (err) {
            return false;
        }
    }

    return str !== null;
}

module.exports = {
    isArray: isArray,
    getType: getType,
    parseValue: parseValue,
    tryParseValue: tryParseValue,
    ParsedValue: ParsedValue
};
