'use strict';

var Assert = require('assert');
var moduleConfig = require('module-config-inc');
var debug = require('debug')('service-instruments-ebay/config');
var Objutil = require('objutil');
var Trooba = require('trooba');
var Async = require('async');
var Resolver = require('./lib/resolver');
var AsyncValue = require('raptor-async/AsyncValue');

var logger = require('logging-inc').logger(
    'service-instruments-ebay/config');

var pipes = {};
var configs = {};

const shortVipRegEx = new RegExp(/(.)*\.(vip|stratus)$/);

/*
 * Config provider that uses module-config-inc if available
 * This is ebay specific functionlity that will be removed once the module goes public
*/
module.exports = function config(pipe, cfg) {
    debug('# config handler invoked', cfg);

    var clientId = pipe.context.clientId;
    var caller = pipe.context.caller;
    var configured = new AsyncValue();
    var error;
    // merge config to request context
    var svcClientConfig;

    if (!clientId) {
        throw new Error('clientId is missing in the context');
    }

    var pipeConfig = configs[clientId];
    if (pipeConfig) {
        debug('# cached pipe config for', clientId);
        resolveAndLink();
    }
    else {
        debug('# creating pipe config for', clientId);
        initResolveAndLink();
    }

    pipe.on('request', function onRequest(request, next) {
        logger.info('config handler for', clientId);
        debug('# running config handler %s with root %s and meta location: %s',
            clientId, caller, cfg && cfg.location || 'default');

        configured.done(function onResolve(err) {
            if (err) {
                return pipe.throw(err);
            }
            // inject client config
            // merge config to request context
            Objutil.deepMerge(svcClientConfig, request);
            next(request);
        });
    });

    function initResolveAndLink() {
        debug('# init pipe config', clientId, caller);
        Async.parallel({
            lib: moduleConfig.bind(null, cfg && cfg.location || module),
            client: moduleConfig.bind(null, caller)
        }, function onConfig(err, config) {
            if (err) {
                configured.reject(err);
                return;
            }

            pipeConfig = configs[clientId] =
                configs[clientId] || new PipeConfig(clientId, config);
            resolveAndLink();
        });
    }

    function resolveAndLink() {
        debug('# resolve a pipe', clientId, caller);
        //HTTPS Overrides
        httpsOverrides(pipeConfig);

        svcClientConfig = pipeConfig.clientConfig;
        var pipeMeta = pipeConfig.resolve(pipe);
        if (pipeMeta.instruments.length) {
            var cfgPipe = pipes[pipeMeta.key];
            if (!cfgPipe) {
                debug('# building the pipe', pipeMeta.key);
                cfgPipe = pipes[pipeMeta.key] = buildPipe(pipeMeta);
            }

            debug('# linking pipe', pipeMeta.key);
            cfgPipe && pipe.link(cfgPipe);
        }
        configured.resolve();
    }
};

function PipeConfig(clientId, config) {
    this.clientId = clientId;
    this.config = config;

    this.initConfig();
    this.loadInstruments();
    this.loadMetadata();
}

module.exports.PipeConfig = PipeConfig;

PipeConfig.prototype.initConfig = function initConfig() {
    debug('# loading configuration for', this.clientId);

    var clientConfig = this.config.client.get('services:' + this.clientId);
    var clientLibConfig = this.config.client.get('service-instruments-ebay');
    var libConfig = this.config.lib.get('service-instruments-ebay');

    if (!clientConfig) {
        throw new Error('Cannot find configuration for clientId: ' + this.clientId);
    }

    // the consumer can also define everything in-line (inside client config)
    // but it is not shared between other clients
    debug('# configuration for', this.clientId, 'is', clientConfig);

    this.clientConfig = clientConfig;
    this.clientLibConfig = clientLibConfig;
    this.libConfig = libConfig;
};

PipeConfig.prototype.loadInstruments = function loadInstruments() {
    const clientConfig = this.clientConfig;
    let instruments = clientConfig.instruments ||
        this.libConfig['default-instruments'] || [];

    if (clientConfig['add-instruments']) {
        // clone it and add to it with concat
        instruments = instruments.concat(clientConfig['add-instruments']);
    }

    // add metrics by default only to the configs with custom instrument list
    // if metrics was not explicitly disabled and is not already in the list
    // of instruments
    if (clientConfig.instruments && clientConfig.metrics !== false && instruments.indexOf('metrics') === -1) {
        instruments = instruments.concat('metrics');
    }

    this.instruments = instruments;
    this.clientConfig = clientConfig;
    this.transport = clientConfig.transport;
};

PipeConfig.prototype.loadMetadata = function loadMetadata() {
    this.instrumentsMeta = this.libConfig['instruments-metadata'];
    if (this.instrumentsMeta) {
        debug('# loaded instrument metadata', this.instrumentsMeta);
        this.instrumentsMeta =
            Resolver.updateInstrumentsMetadata(this.instrumentsMeta);
    }
    if (this.clientLibConfig) {
        var clientInstrumentMeta = this.clientLibConfig['instruments-metadata'];
        this.instrumentsMeta =
            clientInstrumentMeta ?
                Resolver.updateInstrumentsMetadata(clientInstrumentMeta) :
                this.instrumentsMeta;
    }
};

PipeConfig.prototype.resolve = function resolve(pipe) {
    var self = this;
    var key = this.clientId;
    var instruments = pipe.context.instruments || this.instruments;
    debug('# instruments:', instruments);
    // if context has extra instrument metadata resolve it into instrument list
    if (this.instrumentsMeta) {
        instruments = instruments.map(function map(name) {
            if (typeof name === 'string') {
                const meta = self.instrumentsMeta[name];
                if (meta) {
                    return meta;
                }
            }
            return name;
        });
        debug('# resolved instruments', instruments);
    }

    instruments = Resolver.resolveInstruments(instruments);
    instruments.forEach(function forEach(instr) {
        key = key || 'key';
        key += ':' + instr.name;
    });

    var transport = pipe.context.transport || this.transport;
    if (transport) {
        debug('# adding transport from config', transport.name || transport);
        key += ':' + transport;
        // this is lazy binding of transport
        transport = Resolver.resolveInstrumentMeta(transport);
        instruments.push(transport);
    }

    return {
        key: key,
        instruments: instruments,
        config: this.clientConfig
    };
};

function buildPipe(pipeMeta) {
    var pipe = new Trooba();
    // resolve instruments and build pipe
    pipeMeta.instruments.forEach(function forEach(meta) {
        debug('# registering handler', meta.module);
        pipe.use(meta.instrument, pipeMeta.config);
    });

    return pipe.build();
}

function httpsOverrides(pipeConfig) {
    let clientConfig = pipeConfig.clientConfig;
    const httpsEnforcement = process.env.ENABLE_HTTPS === 'true' || process.env.ENABLE_HTTPS === true;
    if (httpsEnforcement) {
        if (!clientConfig.protocol || clientConfig.protocol === 'http:') {
            clientConfig.protocol = 'https:';
            if (clientConfig.port === 80 || clientConfig.port === '80') {
                clientConfig.port = 443;
            }
        }

        if(clientConfig.protocol === 'https:') {
            clientConfig.https = 'eBayRootCert';
        }

        //Check if hostname ends with ".vip" or ".stratus", then append with ".ebay.com"
        //e.g pes.vip => pes.vip.ebay.com
        if(shortVipRegEx.test(clientConfig.hostname)) {
            const vipMapping = pipeConfig.config.lib.get('SvcVipMappingConfig:vipMapping') || {};
            clientConfig.hostname = vipMapping[clientConfig.hostname] || clientConfig.hostname.concat('.ebay.com');
        }

        let instruments = pipeConfig.instruments;
        // if config has custom set of instrument, we should make sure it has https
        if (instruments && instruments.indexOf('https') === -1) {
            // clone it and add to it with concat
            instruments = instruments.concat('https');
            pipeConfig.instruments = instruments;
        }
    }
}
