'use strict';

var NodeUtils = require('util');

var Objutil = require('objutil');

var logger = require('logging-inc').logger('service-instruments-ebay/errors');
/**
 *  Params:
 *  message or error or message and error or options or
 *  options: {
 *      error: error object to wrap,
 *      error-id: <number>
 *      domain: <application domain>
 *      category: <APPLICATION | SYSTEM | USER>
 *      message: error message,
 *      longMessage: error message with more details,
 *      type: <error type, bad-token>
 *      code: error code
 *      statusCode: response status if it is related to http request
 *  }
*/
var RuntimeError = module.exports.RuntimeError = function RuntimeError() {
    var args = [].slice.call(arguments);
    var options = args.reduce(function (memo, param) {
        updateOptions(param, memo);
        return memo;
    }, {});

    var msg = options.message || 'RuntimeError';
    msg = (options.error && 'Re-thrown: ' || '') + msg;

    // create stack trace hook
    this.errorObj = Error.call(this, msg);

    Object.defineProperty(this, 'stack', {
        get: function get() {
            return this.errorObj.stack + (this.originalError ?
                '\n\tOriginal error: ' + this.originalError.stack : '');
        }
    });

    Object.defineProperty(this, 'message', {
        get() {
            return this.errorObj.message +
                (this.error ? ', original error: ' + this.error.message : '');
        },

        set(value) {
            this.errorObj.message = value;
        }
    });

    // preserve original error for stack trace
    options.error && (this.originalError = options.error);

    if (options.error) {
        Objutil.merge(options.error, this);
    }

    // validate options, they should not be null
    Object.keys(options).forEach(function forEach(key) {
        if (options[key] === undefined) {
            logger.error('option %s should not be undefined', key);
        }
    });
    // other frequently used props
    // inherit codes from parent error if any or use defaults
    this.code = options.error && options.error.code || options.code || 1;
    this.type = options.error && options.error.type && options.error.type !== 'error' ? options.error.type : options.type || 'error';
    this.errorId = options.error && options.error.errorId || options.errorId || 1;
    this.domain = options.error && options.error.domain || options.domain || 'unknown';
    this.category = options.error && options.error.category || options.category || 'SYSTEM';
    options.statusCode && (this.statusCode = options.statusCode);

    // validate
    if (this.category && !ErrorCategory[this.category]) {
        logger.error('Invalid category name is used for error: ' + this.category +
            ', should be one of ' + Object.keys(ErrorCategory));
    }
};

NodeUtils.inherits(RuntimeError, Error);

function updateOptions(param, options) {
    options = options || {};
    if (param instanceof Error) {
        options.error = param;
    }
    else if (typeof param === 'string') {
        options.message = param;
    }
    else if (typeof param === 'object') {
        Objutil.mixin(param, options);
    }
}

module.exports.Status = {
    BAD_REQUEST: {
        statusCode: 400
    },

    BAD_TOKEN: {
        statusCode: 401
    },

    BAD_SCOPE: {
        statusCode: 401
    }
};

var ErrorCategory = module.exports.ErrorCategory = {
    APPLICATION: 'APPLICATION',
    USER: 'USER',
    SYSTEM: 'SYSTEM'
};
