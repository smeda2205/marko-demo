'use strict';

var Assert = require('assert');
var Httpunch = require('httpunch');
var Objutil = require('objutil');
var NodeUtils = require('util');

var Cal = require('cal');
var Legacy = require('../lib/legacy');
var debug = require('debug')('service-client-ebay/transport');
var Pkg = require('../package.json');

var MASKED_NAMES = [
    'authorization',
    'Authorization'
];

module.exports.addXFF = function (pipe, request, config) {
    const xffEnabled = request && request.xff !== undefined ? request.xff : config && config.xff;
    if (xffEnabled === false) {
        return;
    }
    const app = pipe.context.app;
    const webRequestHeaders = app && app.request && app.request.headers || {};

    let xff = webRequestHeaders['x-forwarded-for'] || '';

    if (webRequestHeaders['x-ebay-client-ip']) {
        xff += (xff ? ',' : '') + webRequestHeaders['x-ebay-client-ip'];
    }

    if (xff) {
        request.headers['x-forwarded-for'] = xff;
    }
};

module.exports.updateRequest = function updateRequest(request) {
    request.protocol = Httpunch.utils.suffix(request.protocol || 'https:', ':');
    request.method = request.method || 'POST';

    Assert.ok(Httpunch.utils.isHttpMethod(request.method), 'method ' + request.method + ' is not an http method.');
    Assert.ok(request.hostname, 'hostname must be defined.');

    var agent = request.agent || Httpunch.agents.create(request);

    if (!request.headers['user-agent']) {
        request.headers['user-agent'] = Httpunch.utils.userAgentString({
            name: Pkg.name,
            version: Pkg.version
        });
    }

    Legacy.updateRequest(request);

    if (request.search) {
        // adjust for httpunch query string from standard
        request.qs = request.search;
    }

    debug('transport(): %s//%s:%s%s',
        request.protocol,
        request.hostname,
        request.port,
        request.path);
};

function sanitize(obj) {
    if (typeof obj === 'object') {
        return MASKED_NAMES.reduce(function reduce(memo, name) {
            if (obj && obj[name] !== undefined) {
                memo = memo || Objutil.clone(obj);
                memo[name] = '******';
            }
            return memo;
        }, undefined) || obj;
    }
    return obj;
}
module.exports.sanitize = sanitize;

function generateHeadersInfo(headers) {
    if (headers) {
        var evt = Cal.createEvent('request', 'RequestHeaders')
            .addData(sanitize(headers));
        evt.type = evt.parent && evt.parent.name || evt.type;
        evt.complete();
    }
}
module.exports.generateHeadersInfo = generateHeadersInfo;

function generateMetricsEvents(metrics) {
    metrics.events.forEach(function (event) {
        var tx = Cal.createTransaction('request', event.name);
        tx._doComplete = function noon() {};
        tx.type = tx.parent && tx.parent.name || tx.type;
        tx.timestamp = event.start;
        tx.duration = event.duration;
        tx.complete();
    });
}
module.exports.generateMetricsEvents = generateMetricsEvents;

module.exports.attachHostInfo2Error = function attachHostInfo2Error(error, request) {
    if (error && error.message) {
        error.message = NodeUtils.format("Host: %s//%s:%s, error: %s",
            request.protocol,
            request.hostname,
            request.port || 80,
            error.message);
    }
};
