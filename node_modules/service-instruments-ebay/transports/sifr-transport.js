/*jslint browser: true*/
'use strict';

/**===================================================
NOTE: This module is only to handle limitation in IE9.
Once eBay drops support for IE9, we should remove
this module.
=====================================================*/
var httpfy = require('./http-api');
var Utils = require('../lib/browser-utils');
var Legacy = require('../lib/legacy');

var channels = {};

module.exports = function sifrTransport(pipe, config) {
    pipe.on('request', function onRequest(request) {
        request = Utils.mixin(config,
            request, {});

        Legacy.updateRequest(request);

        invoke(request, function onResponse(err, response) {
            if (err) {
                return pipe.throw(err);
            }
            if (response) {
                Utils.deserializeResponseHeaders(response);
            }
            pipe.respond(response);
        });
    });

    httpfy(pipe);
};

function invoke(options, callback) {
    var channelUrl = Utils.options2ChannelUrl(options);
    var channel = channels[channelUrl] || (channels[channelUrl] = new Channel(channelUrl));
    channel.invoke(options, callback);
}

module.exports.invoke = invoke;

function Channel(channelUrl) {
    this.counter = 0;
    this.pending = [];
    this.listeners = {};
    this.iframe = document.createElement("iframe");
    this.iframe.src = channelUrl + '/sifr.html';
    this.channelUrl = channelUrl;
    this.init();
}

Channel.prototype.invoke = function invoke(options, callback) {
    if (this.initState !== 'loaded') {
        this.pending.push({
            options: options,
            callback: callback
        });
        if (this.initState === 'aborted') {
            console.log('attempt to load sifr.html');
            this.init();
        }
        return;
    }

    var messageId = this.counter++;

    // this.iframe.style.display = 'none';
    // this.iframe.style.width = '0px';
    // this.iframe.style.height = '0px';


    // handle response
    var self = this;
    var socketTimeout = options.socketTimeout || 1000;

    // setup this timeout to handle cases when iframe failed to load and we need to
    // re-load it. In such cases timeout from iframe channle will never come
    // so, let's set a longer timeout
    var aboutLoadTimer = window.setTimeout(function handleTimeout() {
        self.abort(new Error('Failed to load sifr.html'));
        handleRespose({
            status: 408,
            data: {
                status: 408,
                errorMessage: 'Failed to load sifr.html'
            }
        });
    }, socketTimeout * 2);

    var handleRespose = Utils.once(function handleRespose(message) {
        // clear longer timeout timer
        window.clearTimeout(aboutLoadTimer);
        delete self.listeners[messageId];

        if (message.status === 200) {
            var body = message.data ? tryParse(message.data.result) : {};
            if (body.code === 'parsererror') {
                return callback(body);
            }
            return callback(undefined, {
                statusCode: message.status,
                body: body,
                headers: message.data.xhr.allResponseHeaders
            });
        }

        // else error
        var err = new Error(message.errorMessage || message.data ? message.data.errorMessage : 'Unknown');
        err.statusCode = message.status;
        if (message.status === 408) {
            err.code = 'ETIMEDOUT';
            err.message = 'Connection timeout';
        }
        callback(err);
    });

    // wait for reponse
    this.listeners[messageId] = handleRespose;

    // send request
    this.iframe.contentWindow.postMessage(JSON.stringify({
        messageId: messageId,
        data: {
            url: Utils.options2Url(options),
            method: options.method,
            isOneWay: callback === undefined,
            settings: {
                timeout: socketTimeout,
                headers: options.headers || {},
                data: options.body
            }
        }
    }), this.channelUrl);

};

function tryParse(data) {
    try {
        return JSON.parse(data);
    }
    catch (err) {
        err.code = 'parsererror';
        return err;
    }
}

Channel.prototype.abort = function abort(err) {
    if (this.initState === 'aborted') {
        return;
    }

    this.initState = 'aborted';
    if (window.stop) {
        window.stop();
    } else {
        document.execCommand && document.execCommand('Stop');
    }
    // clean up dom from bad iframe
    try {
        document.body.removeChild(this.iframe);
    }
    catch (err) {}
    // remove bad channel
    delete channels[this.channelUrl];
    // notify all that we failed
    this.pending.forEach(function (request) {
        request.callback &&
            request.callback(err || new Error('IFrame channel timed out for ' + this.iframe.src));
    }.bind(this));
    // just clean up
    this.pending = [];
};

Channel.prototype.init = function init() {
    if (this.initState === 'loaded') {
        return;
    }

    this.initState = 'loading';

    var container = this.iframe;
    var self = this;

    var timeoutTimer = setTimeout(this.abort.bind(this), 4000);

    // setup TX
    document.body.appendChild(container);
    if (window.navigator.appName !== 'Zombie') {
        // this breaks when zombie headless browser is used
        container.style.display = 'none';
        container.style.width = '0px';
        container.style.height = '0px';
    }

    attachEventHandler(container, 'load', function onload() {
        // clean up
        clearTimeout(timeoutTimer);
        detachEventHandler(container, 'load', onload);
        // mark as inititlized
        self.initState = 'loaded';
        // setup RX channel
        attachEventHandler(window, 'message', self.notify.bind(self));
        // execute requests backlog
        self.pending.forEach(function (request) {
            self.invoke(request.options, request.callback);
        });
        // remove pending requests
        self.pending = [];
    });

};

function attachEventHandler(el, eventName, handler) {
    if (el.addEventListener) {
        el.addEventListener(eventName, handler);
    }
    else if (el.attachEvent) {
        el.attachEvent('on' + eventName, handler);
    }
}

function detachEventHandler(el, eventName, handler) {
    if (el.removeEventListener) {
        el.removeEventListener(eventName, handler);
    }
    else if (el.attachEvent) {
        el.detachEvent('on' + eventName, handler);
    }
}

Channel.prototype.notify = function notify(message) {
    if (message && message.data && message.data.indexOf('"messageId":') !== -1) {
        console.log('Channel response: ', message.data);
        try {
            message = JSON.parse(message.data);
        }
        catch (err) {
            console.log('Failed to parse channel response: ', message);
            return;
        }
        var listener = this.listeners[message.messageId];
        if (listener) {
            listener(message);
        }
    }
};

module.exports.Channel = Channel;
