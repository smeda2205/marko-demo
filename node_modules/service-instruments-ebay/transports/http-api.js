'use strict';

var NodeUtils = require('util');

var httpfy = require('trooba-http-api');
var Hmv = require('header-multi-value-ebay');
var Utils = require('../lib/browser-utils');
var Legacy = require('../lib/legacy');

var Client = httpfy.Client;
var Request = httpfy.Request;
var legacyCounter = 0;

var defer = process && process.nextTick && process.nextTick.bind(process) ||
    setImmediate || function defer(fn) {
        setTimeout(fn, 0); // this is much slower then setImmediate or nextTick
    };
/**
* Provides ebay extended API based on trooba-http-api module
*/
module.exports = function httpApi(pipe) {
    httpfy(pipe, ExtendedClient);
};

module.exports.api = function api(pipe) {
    return new ExtendedClient(pipe);
};

function ExtendedClient() {
    Client.apply(this, arguments);
}
module.exports.ExtendedClient = ExtendedClient;

NodeUtils.inherits(ExtendedClient, Client);

ExtendedClient.prototype.request = function request(request) {
    return Client.prototype.request.call(this, request, ExtendedRequest);
};

// Keep backward compatible with old code
ExtendedClient.prototype.post = function post(options) {
    if (options.body || options.request || options.wsdl) {
        options.method = 'POST';
        return this.request(options);
    }
    return Client.prototype.post.call(this, options);
};


ExtendedClient.prototype.context = function context(ctx) {
    // support request based context or context that is already formated as ctx.app
    if (ctx.res && !ctx.app) {
        ctx = {
            app: {
                request: ctx,
                response: ctx.res
            }
        };
    }
    else {
        ctx = Object.assign({}, ctx);
    }

    var newClient = new ExtendedClient(this.pipe, this.config);
    newClient.ctx = ctx;
    return newClient;
};


function ExtendedRequest() {
    Request.apply(this, arguments);
}
NodeUtils.inherits(ExtendedRequest, Request);

ExtendedRequest.prototype.end = function end(callback) {
    var request = this.request;
    // handle legacy code to keep backward compatibility
    Legacy.updateBody(request);

    var pipe = Request.prototype.end.apply(this);
    var _response;

    if (callback) {
        // we would like to avoid promise capture and stream uncaught errors into callbacks
        callback = asyncCallback(callback);
        // dedup trooba pipe errors thrown via pipe.throw(err)
        var onceCallback = Utils.once(callback);
        pipe.on('response', function onResponse(response, next) {
            if (!pipe.context.$responseStream) {
                return onceCallback(null, response);
            }
            _response = response;
            next();
        });
        pipe.on('response:data', function onData(data, next) {
            callback(null, {
                statusCode: _response.statusCode,
                body: data
            });
            next();
        });
        pipe.on('error', function onErr(err) {
            onceCallback(err);
        });
    }

    return pipe;
};

function asyncCallback(orig) {
    return function () {
        defer(() => {
            orig.apply(null, arguments);
        });
    };
}

// add multi value support
ExtendedRequest.prototype.set = function set(key, value) {
    var hmvKey;
    // adding support for multi value headers on server and client side
    if (arguments.length === 3) {
        hmvKey = arguments[0];
        key = arguments[1];
        value = arguments[2];
        var current = this.request.headers[hmvKey];
        if (current) {
            if (typeof current !== 'object') {
                // assume multivalue is already stringified, so parse it back
                current = Hmv.parse(current);
            }
        }
        else {
            // if does not exist, create one
            current = Hmv.create({});
        }
        // set the value
        current.set(key, value);
        // make sure it is set back to headers (it will be stringified automatically via toString)
        this.request.headers[hmvKey] = current;
        this.request.mvheaders = this.request.mvheaders || {};
        this.request.mvheaders[hmvKey] = true;
    }
    else if (arguments.length === 1) {
        hmvKey = arguments[0];
        var self = this;
        return {
            set: function _set(name, value) {
                self.set(hmvKey, name, value);
                return this;
            },
            build: function _build() {
                return self;
            }
        };
    }
    else {
        Request.prototype.set.apply(this, arguments);
    }
    return this;
};

// backwards compatibility with legacy code
ExtendedRequest.prototype.header = function headerDeprecated(key, value) {
    showDeprecationMessage('header(key, value) function has been deprecated, please use set(key, value)');
    return this.set.apply(this, arguments);
};

ExtendedRequest.prototype.headers = function headersDeprecated(kvps) {
    showDeprecationMessage('headers(kvps) function has been deprecated, please use set(key, value) to set header values');
    var self = this;
    Object.keys(kvps).forEach(function forEach(key) {
        self.set(key, kvps[key]);
    });
    return this;
};

ExtendedRequest.prototype.fallback = function fallback(fn) {
    this.context.fallback = fn;
    return this;
};

function showDeprecationMessage() {
    if (legacyCounter++ < 20) {
        console.log.apply(console, arguments);
    }
}
