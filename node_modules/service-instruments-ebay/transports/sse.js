'use strict';

var cal = require('cal');

var Stream = require('streams-ebay'),
    EventStream = Stream.EventStream,
    ChunkedStream = Stream.ChunkedStream,
    Hoek = require('hoek'),
    httpfy = require('./http-api');

var Objutil = require('objutil');
var StreamUtils = require('./stream-utils');
var TransportUtils = require('./utils');

/**
 * Generic transport is just a passthrough to httpunch (regular http request) with JSON parsing for JSON content-type.
 * @type {exports}
 */
module.exports = function sseTransport(pipe, config) {

    pipe.on('request', function onRequest(request) {
        var st = Date.now();
        var req;
        var responseStream;
        var isFinished;

        var onceError = Hoek.once(function onErr(err) {
            isFinished = true;
            pipe.throw(err);
        });

        config && Objutil.merge(config, request);

        var eventhose = new EventStream();

        eventhose
        .on('data', function onstreamdata(eventdata) {
            var eventErr;

            if (eventdata) {

                if (eventdata.is('error')) {
                    eventErr = eventdata;
                } else if (eventdata.is('end-event')) {
                    this.emit('end');
                    return;
                }

                if (req.res.headers['sse-content-type'] === 'application/json') {
                    eventdata = eventdata.toJson();
                }

                cal.createTransaction('Model', eventdata.name, function(
                    err, event) {
                    event.timestamp = st;
                    event.complete();
                });
            }

            if (eventErr) {
                eventErr = new Error('Error Event Received');
                eventErr = Objutil.mixin(eventdata, eventErr);
                pipe.throw(eventErr);
            } else {
                responseStream = responseStream || pipe.streamResponse(req.res);
                responseStream.write(eventdata);
            }

        })
        .once('error', function onstreamfinish(err) {
            var statusCode = req.res && req.res.statusCode;

            statusCode = statusCode >= 400 ? statusCode : statusCode;
            err.statusCode = statusCode || 'ParseError';

            onceError(err);
        })
        .once('finish', function onstreamfinish() {
            if (isFinished) {
                return;
            }
            if (!responseStream) {
                return pipe.respond(req.res);
            }
            responseStream.end();
        });

        // add x-forwarded-for
        TransportUtils.addXFF(pipe, request, config);

        req = StreamUtils.startStream(request);
        req.on('error', onceError);
        req.once('response', function onResponse(response) {
            req.res = response;
            if (response.statusCode >= 300) {
                /** Handle this for redirection cases separately..
                    Redirections are valid data
                ***/
                response.once('finish', function onFinish() {
                    pipe.respond(req.res);
                });
                return;
            }

            var stream = new ChunkedStream();
            stream.pipe(eventhose);
            response.pipe(stream);
        });

        req.end();
    });

    httpfy(pipe);
};
