'use strict';

var querystring = require('querystring');
var NodePath = require('path');
var NodeUtils = require('util');
let qs = require('querystring');

var cal = require('cal');
var logger = require('logging-inc').logger('service-instruments-ebay/cal');

var RuntimeError = require('./lib/errors').RuntimeError;

module.exports = function calHandler(pipe, config) {
    var _request;
    var _tx;
    var clientId = pipe.context.clientId;

    pipe.once('request', function onRequest(request, next) {
        var options = request;
        _request = request;
        var self = this;
        logger.info('cal handler', clientId);

        var txName = clientId + (options.operation ? '.' + options.operation : '');
        logger.begin('Service', txName, function OnTx(tx) {
            _tx = tx;
            var url = formatUrl(options);
            cal.createEvent(clientId, 'RequestURL').addData(url).complete();

            next();

        });
    });

    pipe.once('error', function onErr(err, next) {
        if (err.res) {
            logResponse(err.res);
        }
        // in case of error we would like to know more information about
        // request headers
        logRequest(_request);

        let errorMessage = err && err.message || 'Unknown error';
        const port = _request.port !== undefined ? _request.port : (_request.protocol === 'http:' ? 80 : 443);
        errorMessage = `Host: ${_request.protocol || 'https:'}//${_request.hostname}:${port}, error: ${errorMessage}`;

        err = new RuntimeError(errorMessage, {
            error: err,
            code: err.code || 'Error'
        });

        _tx.fail(err.errorMessage, err, 1, {Errors: err.errorCount || 0});
        next(err);
    });

    pipe.once('response', function onResponse(response, next) {
        logResponse(response);

        _tx.addData({Errors: pipe.context.errorCount || 0});
        _tx.end();

        next();
    });

    function logResponse(response) {
        response.headers && cal.createEvent(clientId, 'ResponseHeaders')
            .addData(formatHeaders(response.headers)).complete();

        response.statusCode && cal.createEvent(clientId, 'HttpStatus')
            .addData(response.statusCode).complete();
    }

    function logRequest(request) {
        const debug = config && config.debug;
        if (!debug && _request && _request.headers) {
            const headers = request.headers;
            // sanitize the headers
            if (headers.authorization) {
                headers.authorization = '***';
            }
            cal.createEvent(clientId, 'RequestHeaders')
                .addData(formatHeaders(headers)).complete();

        }
    }
};

function formatUrl(options) {
    var qs = options.qs ? (typeof options.qs === 'string' ? options.qs : querystring.stringify(options.qs)) : options.search || '';
    qs = qs ? '?' + qs : '';

    return NodeUtils.format('%s//%s:%s%s%s',
        options.protocol,
        options.hostname,
        options.port || (options.protocol === 'https:' ? 443 : 80),
        NodePath.join(options.basepath || '', options.path || ''),
        qs);
}

function formatHeaders(headers) {
    return qs.stringify(headers);
}
