"use strict";

var Assert = require('assert');
var Fs = require('fs');
var Util = require('util');
var Objutil = require('objutil');
var open_wsdl = require('soap-temp-ebay/lib/wsdl').open_wsdl;
var DataHolder = require('raptor-async/DataHolder');
var Builder = require('./builder');
var Adaptor = require('./adaptor');
var Utils = require('./utils');
var _ = require('underscore');

var builders = {};

var _wsdlCache = {};

module.exports = function soap(pipe) {
    var builder;
    var marshalTime;
    var options;

    pipe.on('request', function onRequest(request, next) {
        options = request;

        createBuilder(options, function buildRequest(err, bldr) {
            if (err) {
                return pipe.throw(err);
            }

            builder = bldr;

            Utils.instrument(builder.wsdl, options);

            var start = Date.now();
            var requestOptions = builder.build(options);
            marshalTime = Date.now() - start;

            delete options.body;
            Objutil.deepMerge(options, requestOptions);

            options.output = requestOptions.output;
            delete requestOptions.output;

            Adaptor.adapt(requestOptions, builder.wsdl);
            requestOptions.headers = Utils.normalizeHeaders(requestOptions.headers);
            request = requestOptions;

            next(request);
        });
    });

    pipe.on('response', function onResponse(response, next) {

        response.body = response.body.toString();

        var start = Date.now();
        var obj = tryXmlToObject(builder.wsdl, response);
        var unmarshalTime = Date.now() - start;
        if (pipe.context.metrics) {
            pipe.context.metrics.update('unmarshalTime', unmarshalTime);
            pipe.context.metrics.update('marshalTime', marshalTime);
        }

        if (obj instanceof Error) {
            if (response.statusCode >= 300) {
                obj = boom(response);
            }
            return pipe.throw(obj);
        }

        response.body = obj.Body[options.output .$name];
        // RPC/literal response body may contain elements with added suffixes I.E.
        // 'Response', or 'Output', or 'Out'
        // This doesn't necessarily equal the ouput message name. See WSDL 1.1 Section 2.4.5
        if (!response.body) {
            response.body = obj.Body[options.output .$name.replace(/(?:Out(?:put)?|Response)$/, '')];
        }

        if (response.statusCode >= 400 ||
            response.body && response.body.errorMessage) {

            return pipe.throw(boom(response.statusCode >= 400 ?
                response : response.body));
        }

        response.headers = response.headers ||
            response.body && response.body.headers;

        // to preserve backward compatibility
        response.__attrib = response.attributes;

        next();
    });


};

function tryXmlToObject(wsdl, response) {
    try {
        return wsdl.xmlToObject(response.body);
    } catch (error) {
        return new Error(error.message + ', response:' + response.body);
    }
}

function boom(response) {

    var err;

    if (response && response.errorMessage) {
        err = _.extend(new Error('Server returned error: ' +
                Util.inspect(response.errorMessage, null, 4)),
                    {errorMessage: response.errorMessage});
        err.code = 'ServerError';
        err.response = response;
    }
    else {
        err = new Error('Status code: ' +
            (response && response.statusCode || '500') +
            ', message: ' +
            (response.body || 'Unknown error'));
        err.statusCode = response && response.statusCode || 500;
        err.code = 'HTTP' + err.statusCode;
        err.response = response;
    }

    return err;
}

var loadWSDL = module.exports.loadWSDL = function loadWSDL(options, callback) {

    Assert.ok(options.wsdl, 'WSDL file must be provided');

    // allow only file based WSDL
    Assert.ok(Fs.existsSync(options.wsdl), 'Cannot find location of wsdl file');

    var wsdlObj = _wsdlCache[options.wsdl];
    if (wsdlObj) {
        process.nextTick(function() {
            callback(null, wsdlObj);
        });
    } else {
        open_wsdl(options.wsdl, options, function(err, wsdl) {
            if (err) {
                return callback(err);
            }
            else {
                _wsdlCache[options.wsdl] = wsdl;
            }
            callback(null, wsdl);
        });
    }
};

var createBuilder = module.exports.createBuilder = function createBuilder(options, callback) {
    Assert.ok(options.wsdl, 'wsdl must be specified');
    var id = options.wsdl;
    var builderHolder = builders[id] = builders[id] || (function () {
        var holder = new DataHolder();
        loadWSDL(options, function(err, wsdl) {
            if (err || !wsdl) {
                delete builders[id];
                return holder.reject(err || new Error('Cannot load wsdl file: ' + options.wsdl));
            }
            holder.resolve(new Builder(wsdl, options));
        });
        return holder;
    })();

    builderHolder.done(callback);
};

module.exports.SOA_HEADERS = require('./soa-headers');
module.exports.reset = function reset() {
    _wsdlCache = {};
};
