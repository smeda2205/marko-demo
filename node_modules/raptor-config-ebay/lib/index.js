'use strict';

var _ = require('underscore'),
    util = require('util'),
    async = require('async'),
    BitSet = require('bit-set'),
    EventEmitter = require('events').EventEmitter,
    debug =  require('debug')('raptorconfig:index');

var modConfig, configBean = require('config-bean-ebay');

var utils = require('./utils');

var moduleConfig = {
    forceUpdate: false,
    configBean: undefined,
    serviceConfig: undefined,
    refreshInterval: undefined
};

var raptorConfigService;

/**
 * Loaded cache is a map of config ref as string key, and a loaded structure as value.
 * Loaded value looks like the following
 *  {
 *      "latest": "",
 *      "baseline": [],
 *      "changes": {
 *          "": [],
 *          "changeset-0": []
 *      },
 *      "listeners":[],
 *      "timer":Object
 *  }
 */

var _cache = {};
var _pageSize = 1000;

//create config bean for Raptor Config if not created already
if (!configBean.getBeanById(utils.configBeanId)) {
    utils.defineBean();
}

function setTimer(self, configSpec, config) {
    configSpec = _.pick(configSpec, ['domain', 'target', 'project', 'config', 'version']);
    if (!config.timer) {
        config.timerFunction = _.bind(self.notify, self, configSpec);
        setupTimer(config);
    }
}

function setupTimer(config, randomDelay) {
    config.timerInterval = getRefreshIntervalInMills();

    config.timer = setTimeout(function() {
        // since this runs out of request context and can run as long as worker is up
        // we should clean up domains to disconnect from any context that may be cached here
        while(process.domain) {process.domain.exit();}
        clearTimeout(config.timer);
        config.timer = undefined;
        config.timerFunction();
    }, randomDelay || config.timerInterval);

    config.timer.unref(); // Make sure our interval does not keep node from exiting
}

function getRefreshIntervalInMills() {
    if (process.env.RAPTOR_REFRESH_INTERVAL) {
        return process.env.RAPTOR_REFRESH_INTERVAL;
    }

    var interval = moduleConfig.refreshInterval ? (moduleConfig.refreshInterval < 1 ? 1 : moduleConfig.refreshInterval) : 1;
    return interval * 60 * 1000;
}

function updateTimers() {
    var minTimeout = 1000; // 1 Second
    var maxTimeout = getRefreshIntervalInMills();

    _.each(_cache, function (config) {
        var randomDelay = Math.floor(Math.random() * (maxTimeout - minTimeout + 1)) + minTimeout;

        if (config.timer && config.timerInterval !== maxTimeout) {
            clearTimeout(config.timer);

            config.timer = undefined;
            config.timeInterval = maxTimeout;
            setupTimer(config, randomDelay); // Randomize Start Time
        }
    });
}

function forceUpdateConfigs() {
    _.each(_cache, function (config) {
        if(config.timerFunction) {
            config.timer && clearTimeout(config.timer); // cancel any regualr refresh
            config.forceUpdateTimer && clearImmediate(config.forceUpdateTimer); // cancel any pending forceUpdateTimer
            config.forceUpdateTimer = setImmediate(function() {
                config.forceUpdateTimer = undefined;
                config.timerFunction();
            });
        }
    });
}

function onConfigChange() {
    var refreshconfigBean = moduleConfig.configBean.get('refreshconfig');

    if (moduleConfig.forceUpdate !== refreshconfigBean.forceUpdate) {
        moduleConfig.forceUpdate = refreshconfigBean.forceUpdate;
        forceUpdateConfigs();
    }

    if (moduleConfig.refreshInterval !== refreshconfigBean.refreshInterval) {
        moduleConfig.refreshInterval = refreshconfigBean.refreshInterval;
        updateTimers();
    }
}

/**
 * acquire the change sets
 * @param message
 * @param changeSet
 * @param callback
 */
function acquireChanges(configSpec, callback) {
    var changes,
        cacheKey = utils.buildLoadKey(configSpec),
        config = _cache[cacheKey];

    latestChangesetId(configSpec, function (error, changeSet) {
        if (error && !changeSet) {
            return callback(error, null);
        }

        /**
         * If there are no change sets or if we received an empty changeset erroneously or we have the
         * changeset in cache just invoke callback with the last read changeset or baseline.
         */

        if (changeSet.length === 0 || _.isEqual('', changeSet) || _.isEqual(config.latest, changeSet)) {
            var latest = config.changes[config.latest] || config.baseline;

            changes = {
                validContexts: latest.validContexts,
                properties: latest.properties
            };

            return callback(null, changes);
        }

        debug('in:%d change detected, from:%s to:%s', process.pid, config.latest || 'baseline', changeSet);

        var params = utils.changesQuery(configSpec, changeSet);

        raptorConfigService.getChangeSet(params, configSpec.options, function (err, result) {
            if (!result || err) {
                return callback(err, null);
            }

            var changesGroupedByOffsets = groupByOffset(result);

            //persist states
            config.latest = changeSet;
            config.changes[changeSet] = {
                validContexts: _.compact(result.meta && result.meta.validContextList || []),
                properties: applyChanges(config && config.baseline, changesGroupedByOffsets)
            };

            changes = config.changes[changeSet];
            return callback(null, changes);
        });
    });
}

function groupByOffset(result) {
    var changesGroupedByOffsets = {};

    if (!result || !result.changesList) {
        return changesGroupedByOffsets;
    }

    result.changesList.forEach(function (change) {
        if (change) {
            var changesAtOffset = changesGroupedByOffsets[change.offset] || [];
            changesAtOffset.push({
                'uid': change.uid,
                'key': change.key && change.key.trim(),
                'context': change.contextList,
                'value': utils.resolveValueByType(change.valueList, change.valueType),
                'action': change.action,
                'offset': change.offset
            });
            changesGroupedByOffsets[change.offset] = changesAtOffset;
        }
    });

    return changesGroupedByOffsets;
}

function applyChanges(baseline, changesGroupedByOffsets) {
    var i, j;
    var effectives = {};
    var applied = new BitSet();

    if (baseline) {
        baseline.properties.forEach(function (property) {
            //group by offset
            effectives[property.offset] = utils.applyChanges(property, changesGroupedByOffsets);
        });
    }

    for (i in changesGroupedByOffsets) {
        var changesAtOffset = changesGroupedByOffsets[i];
        if (changesAtOffset) {
            for (j in changesAtOffset) {
                var property = changesAtOffset[j];
                if (property && !applied.get(property.offset) && property.action !== 0) {
                    effectives[property.offset] = utils.applyChanges(property, changesGroupedByOffsets);
                    (effectives[property.offset] ? BitSet.prototype.set : BitSet.prototype.clear).apply(applied, [property.offset]);
                }
            }
        }
    }

    return effectives;
}

/**
 * load a single page with offset boundaries, for batched config loadings
 * @param message
 * @param offset
 * @param limit
 * @param callback
 */
function loadBaseline(configSpec, offset, limit, callback) {
    var params = utils.baselineQuery(configSpec, offset, limit);
    raptorConfigService.getBaseline(params, configSpec.options, callback);
}

function loadLatest(self, configSpec, config) {
    //loading the config, batched by _pageSize
    loadBaseline(configSpec, 0, _pageSize, function (error, page) {
        if (!page || error) {
            configSpec.error = error;
            self.emitReadEvent(configSpec, []);
            return;
        }

        config.baseline.validContexts = _.compact(page.meta && page.meta.validContextList || []);
        config.baseline.properties = config.baseline.properties || [];

        if (page.propertyList) {
            page.propertyList.forEach(function (property) {
                if (property && property.key) {
                    config.baseline.properties.push({
                        'uid': property.uid,
                        'key': property.key && property.key.trim(),
                        'context': property.contextList,
                        'value': utils.resolveValueByType(property.valueList, property.valueType),
                        'offset': property.offset
                    });
                }
            });
        }

        //finished loading baseline
        if (page.endOfDocument) {
            // now load latest changeset
            acquireChanges(configSpec, function (error, properties) {
                if (error && !properties) {
                    configSpec.error = error;
                }
                self.emitReadEvent(configSpec, properties || []);
            });
        } else  {
            //must load the rest of the pages
            //each _pageSize limit page, starting from _pageSize

            async.each(_.range(_pageSize, page && page.totalDocuments || 0, _pageSize), function (offset, cb) {
                //using defer + promise to guarantee that the notifyChanges won't be called till all pages have been fetched over
                loadBaseline(configSpec, offset, _pageSize, function (error, page) {
                    if (!page || error) {
                        return cb(error, null);
                    }
                    if (page.propertyList) {
                        page.propertyList.forEach(function (property) {
                            if (property) {
                                config.baseline.properties.push({
                                    'uid': property.uid,
                                    'key': property.key && property.key.trim(),
                                    'context': property.contextList,
                                    'value': utils.resolveValueByType(property.valueList, property.valueType),
                                    'offset': property.offset
                                });
                            }
                        });
                    }
                    return cb(null, page);
                });
            }, function (errors, results) {
                acquireChanges(configSpec, function (error, properties) {
                    if (error && !properties) {
                        configSpec.error = error;
                    }
                    self.emitReadEvent(configSpec, properties || []);
                });
            });
        }
    });
}

//find the latest change set associated with the config baseline
function latestChangesetId(configSpec, callback) {
    var params = utils.latestChangeSetQuery(configSpec);
    raptorConfigService.getLatestChangeSet(params, configSpec.options, callback);
}

function RaptorConfig() {}
util.inherits(RaptorConfig, EventEmitter);

/**
 * Initialize and cache config,
 * As this module contribute back to module-config-inc,
 * OK to cache it here
 * Lazy load module config and raptor config service
 */
RaptorConfig.prototype._init = function () {
    if (!moduleConfig.serviceConfig) {
        modConfig = modConfig || require('module-config-inc');

        moduleConfig.configBean = modConfig(module);
        moduleConfig.serviceConfig = moduleConfig.configBean.get('services:raptorconfig');

        // Cache config value and bind on change listener
        var refreshconfig = moduleConfig.configBean.get('refreshconfig');
        moduleConfig.forceUpdate = refreshconfig.forceUpdate;
        moduleConfig.refreshInterval = refreshconfig.refreshInterval;
        moduleConfig.configBean.on('change', onConfigChange);
    }

    if (!raptorConfigService) {
        raptorConfigService = require('./ConfigService')();
    }
};

//main api, loading a config based on the ref defined in the given message;
RaptorConfig.prototype.load = function (configSpec) {
    this._init();

    var serviceConfig = moduleConfig.serviceConfig;
    var refreshConfig = moduleConfig.configBean.get('refreshconfig');

    configSpec = configSpec && _.pick(configSpec, ['domain', 'target', 'project', 'config', 'version']) || {};
    configSpec.base = [serviceConfig.protocol, '//',
                    serviceConfig.hostname, ':', serviceConfig.port,
                    serviceConfig.basepath].join('');
    configSpec.domain = configSpec.domain || refreshConfig.domain;
    configSpec.target = configSpec.target || refreshConfig.target;

    var cacheKey = utils.buildLoadKey(configSpec);
    var config = _cache[cacheKey] || {
        'changes': {}
    };
    _cache[cacheKey] = config;

    config.baseline = {
        'validContexts': [],
        'properties': []
    };

    loadLatest(this, configSpec, config);
};

//emit the 'read' event
RaptorConfig.prototype.emitReadEvent = function (configSpec, latestConfig) {
    var response = {};

    if (configSpec) {
        _.extend(response, configSpec);
    }

    if (latestConfig) {
        _.extend(response, {
            'type': 'read',
            'message': _.extend({}, configSpec),
            'properties': latestConfig.properties,
            'validContexts': latestConfig.validContexts
        });
    }

    var config = _cache[utils.buildLoadKey(configSpec)];
    setTimer(this, configSpec, config);
    this.emit('read', response);
};

//scheduled job that acquires latest change set
RaptorConfig.prototype.notify = function notify(configSpec) {
    var self = this;
    var config = _cache[utils.buildLoadKey(configSpec)];
    configSpec = _.pick(configSpec, ['domain', 'target', 'project', 'config', 'version']);

    debug('refeshing', configSpec);

    if (config.baseline &&
            config.baseline.properties &&
            config.baseline.properties.length === 0) {

        config.latest = undefined;
        loadLatest(self, configSpec, config);
        return;
    }

    acquireChanges(configSpec, function (error, config) {
        if (error && !config) {
            configSpec.error = error;
        }
        self.emitReadEvent(configSpec, config || []);
    });
};

//shutdown all schedulers
RaptorConfig.shutdown = function shutdown() {
    _.each(_cache, function (config, key) {
        if (config.timer) {
            clearTimeout(config.timer);
            config.timer = null;
        }

        config.forceUpdateTimer && clearImmediate(config.forceUpdateTimer);
    });

    _cache = {};
    modConfig && modConfig.cache.clear();
};

module.exports = RaptorConfig;
