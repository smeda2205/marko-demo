'use strict';

var objutil = require('objutil'),
    EventEmitter = require('events').EventEmitter,
    querystring = require('querystring'),
    constants = require('../constants'),
    calbuffer = require('../calbuffer'),
    threads = require('../threads'),
    nsutils = require('../nsutils'),
    debug = require('debug')('cal:activity'),
    calProhibitedCharsRegex = /[/ '"<>\t\n]/g,  //'
    calProhibitedNonAsciiChars = /[^\x20-\x7E]/g,
    PIIKeywords = require('../../config/config.json').PIIKeywords;

function BaseActivity(type, name, status, data) {
    this._type   = type   || constants.UNSET;
    this._name   = name   || constants.UNSET;
    this._status = status || constants.Status.SUCCESS;
    this._data   = (typeof data === 'string') ? data : (data || Object.create(null));
    this._klass  = undefined;
    this._timestamp = Date.now();
    this._type = sanitize(this._type);
    this._name = sanitize(this._name);
    this._flushBuffer = false;

    this._isNestedCalEvents = nsutils.get(constants.IS_NESTED_CAL) || false;
    this._bufferFlushDelay = nsutils.get(constants.BUFFER_FLUSH_DELAY, 0);
    this._isBufferingEnabled = nsutils.get(constants.IS_BUFFERING) || this._isNestedCalEvents || false;
    this._bufferable = true;
}

// Remove characters CAL will not accept.
// https://confluence.paypal.com/cnfl/display/CAL/CAL+Message+Guidelines#CALMessageGuidelines-G6CALMessageTypeandNamefieldguidelines
function sanitize(str) {
    var s = str;
    if (s && typeof s === 'string') {
        s = str.replace(calProhibitedCharsRegex, '_');
        s = s.replace(calProhibitedNonAsciiChars, '_');
        if (s.length > 127) {
            s = s.substr(0, 127);
        }
    }
    return s;
}

//Filtering known PII from CAL
function isPIISafe(key) {
    if (PIIKeywords.indexOf(key) > -1) {
        return false;
    }
    return true;
}

objutil.extend(BaseActivity, EventEmitter, {

    get messageClass() {
        return this._klass;
    },

    set messageClass(value) {
        this._klass = value;
    },


    get type() {
        return this._type;
    },

    set type(value) {
        this._type = sanitize(value);
    },


    get name() {
        return this._name;
    },

    set name(value) {
        this._name = sanitize(value);
    },


    get status() {
        return this._status;
    },

    set status(value) {
        this._status = String(value);
    },


    get timestamp() {
        return this._timestamp;
    },

    set timestamp(value) {
        this._timestamp = value;
    },

    get threadId() {
        this._threadId = this._threadId || threads.getThreadId() || constants.DEFAULT_THREAD_ID;
        return this._threadId;
    },

    set threadId(threadId) {
        this._threadId = threadId;
    },

    get eventId() {
        return this._eventId;
    },

    set eventId(value) {
        this._eventId = value;
    },

    get parent() {
        return this._parent;
    },

    set parent(value) {
        this._parent = value;
    },

    get parentEventId() {
        return this._parent && this._parent.eventId || 0;
    },

    get flushBuffer() {
        return this._flushBuffer;
    },

    set flushBuffer(value) {
        this._flushBuffer = value;
    },


    addData: function (key, value) {

        if (value !== undefined) {

            if (isPIISafe(key)) {
                // Both args are set, so just update data
                this._data[key] = value;
            }

        } else {

            if (typeof key === 'object') {
                // Copy values to data
                Object.keys(key).forEach(function (prop) {
                    if (isPIISafe(prop)) {
                        this._data[prop] = key[prop];
                    }
                }.bind(this));
            } else {
                this._data.msg = this._data.msg || [];
                this._data.msg.push(key);
            }
        }
        return this;
    },

    getCalBuffer: function () {
        return calbuffer.getCalBuffer(this.threadId, this._isNestedCalEvents, this._bufferFlushDelay);
    },

    complete: function (status) {

        if (status !== undefined) {
            this.status = status;
        }

        this._doComplete();

        var eventArgs = this._getEventArgs();

        if (this._bufferable && this._isBufferingEnabled &&
            // do not store flushed events
            !(this.parent && this.parent._flushed || this._flushed)) {

            var buffer = this.getCalBuffer();
            var parentEventId = eventArgs.parentEventId || 0;
            buffer.push({instance: this, eventName: 'complete', args: eventArgs});

            if (parentEventId === 0) {
                buffer.flushAll();
                this._flushed = true;
            }
        } else {
            this.emit('complete', eventArgs);
            this._flushed = true;
        }
        // restore to parent just in case the chain continue,
        // while it should never happen at runtime, only in unit tests
        const parent = (this.parent && !this.parent._flushed) ? this.parent : null;
        parent && nsutils.set(constants.TX, parent);
    },


    _doComplete: function () {
        // noop
    },


    _getEventArgs: function () {
        var eventArgs, extraArgs;

        eventArgs = {
            type:   this.type,
            name:   this.name,
            status: this.status,
            data:   this._data,
            messageClass: this._klass,
            timestamp:    this.timestamp,
            threadId: this.threadId,
            eventId: this.eventId,
            parentEventId: this.parentEventId || 0
        };

        extraArgs = this._doGetEventArgs();
        if (extraArgs) {
            Object.getOwnPropertyNames(extraArgs).forEach(function (prop) {
                eventArgs[prop] = extraArgs[prop];
            });
        }
        return eventArgs;
    },


    _doGetEventArgs: function () {
        // noop
        return undefined;
    }

});


exports = module.exports = BaseActivity;
