'use strict';

//For better CAL view, sorting calThreadIDPool

var calThreadIDPool = [],
    timeoutId,
    sortTimeoutId,
    threadIdReleaseInterval = 150, //150ms
    timerSortInterval = 25000,  // 25sec
    timerResetInterval = 60000;  // 1min
var fakeCALThreadCounter = 2;
var constants = require('./constants');
var nsutils = require('./nsutils');
var calbuffer = require('./calbuffer');
var threadHour = 0;

function resetThreadId(hour) {
    hour = hour !== undefined ? hour : new Date().getHours();
    fakeCALThreadCounter = 2;
    // constructing 0xN000 + 0x0H00 + counter to have different thread every hour for 12 hour period
    // we need to have CAL reset the channel with new thread id in case the thread channel
    // is messed up
    if (process.env.pm_id) {
        var pm2Id = parseInt('0x' + 1000 * parseInt(process.env.pm_id, 10), 16);
        fakeCALThreadCounter = pm2Id + fakeCALThreadCounter;
    }
    fakeCALThreadCounter = ((hour % 12) << 8) + fakeCALThreadCounter;
}

resetThreadId();

function compareNumbers(a, b) {
    return a - b;
}

//For better CAL view, sorting calThreadIDPool every timerSortInterval
function sortThreadIdPool() {
    calThreadIDPool.sort(compareNumbers);
}

var resetThreadIdPool = exports.resetThreadIdPool = function resetThreadIdPool() {
    calThreadIDPool = [];
    resetThreadId();
};

exports.getNextThreadId = function getNextThreadId() {
    var threadId;
    var curDate = new Date();
    if (threadHour !== curDate.getHours()) {
        threadHour = curDate.getHours();
        resetThreadIdPool();
    }

    if (calThreadIDPool.length > 0) {
        threadId = calThreadIDPool.shift();
    }

    if (!threadId) {
        threadId = fakeCALThreadCounter++;
    }

    if (timeoutId) {
        clearTimeout(timeoutId);
    }

    if (sortTimeoutId) {
        clearTimeout(sortTimeoutId);
    }

    timeoutId = setTimeout(resetThreadIdPool, timerResetInterval);

    //Sort threadId pool
    sortTimeoutId = setTimeout(sortThreadIdPool, timerSortInterval);

    timeoutId.unref();
    sortTimeoutId.unref();

    return threadId;
};

exports.resetThreadId = resetThreadId;

// Release thread Id for reuse after 150 ms gap
exports.releaseThreadId = function releaseThreadId(threadId) {
    var interval = Math.max(nsutils.get(constants.BUFFER_FLUSH_DELAY, threadIdReleaseInterval),
        threadIdReleaseInterval);

    setTimeout(function () {
        if (calThreadIDPool.indexOf(threadId) === -1) {
            calThreadIDPool.push(threadId);
        }
    }, interval);
};

exports.setThreadId = function setThreadId(threadId) {
    var oldThreadId = nsutils.getValue(constants.THREAD_ID);
    var isBufferingEnabled = nsutils.get(constants.IS_BUFFERING) || false;
    if (oldThreadId && isBufferingEnabled) {
        calbuffer.move(oldThreadId, threadId, true);
    }
    nsutils.setValue(constants.THREAD_ID, threadId);
};

exports.getThreadId = function () {
    return nsutils.get(constants.THREAD_ID, constants.DEFAULT_THREAD_ID);
};
