'use strict';

var os = require('os'),
    util = require('util'),
    async = require('async'),
    domain = require('domain'),
    events  = require('events'),
    objutil = require('objutil'),
    constants = require('./constants'),
    debug = require('debug')('cal:queue');

var debuggers = {},
    DEFAULT_POOL_SIZE = 10;

var LRU = require('lru-cache'),
    cacheOptions = {
        max: 15
    },
    calStreamPool = LRU(cacheOptions);
//Adding LRU cache to cleanup zombie streamPool


function getPoolSize() {
    var cpus,
        instances,
        poolSize = DEFAULT_POOL_SIZE;

    if (process.env.pm_id) {    //means running multiple node processes
        cpus = os.cpus();

        if (process.env.cluster_instance) {
            instances = +process.env.cluster_instance || 'max';
        }

        if (instances && instances === 'max') {
            instances = cpus.length - 1;
        } else if (!instances) {
            instances = 1;
        }

        instances = Math.max(Math.min(instances, DEFAULT_POOL_SIZE), 1) || 1;

        if (cpus && cpus.length > 1) {
            poolSize = DEFAULT_POOL_SIZE / instances;
            poolSize = Math.max(parseInt(poolSize, 10), 1);
        }
    }
    return poolSize;
}

function _closeStream(streamX) {
    try {
        streamX.stream && streamX.stream.end();
    } catch (e) {
        //No op
        debug('error closing stream');
    }
}

function StreamQueue(options) {
    StreamQueue.super_.apply(this, arguments);
    this._options = options || {};
    this._subscription;
    this._subscriptionTopic;

    this._listener = this._writeOnce.bind(this);
    this._poolSize = getPoolSize();
}

module.exports = StreamQueue;

objutil.extend(StreamQueue, events.EventEmitter, {

    get options() {
        return this._options;
    },

    set options(value) {
        this._options = value;
    },

    subscribe: function (publisher, topic) {
        if (this._subscription) {
            // unsubscribe first
            this._subscription.removeListener(this._subscriptionTopic, this._listener);
        }

        publisher.on(topic, this._listener);
        this._subscription = publisher;
        this._subscriptionTopic = topic;
    },

    unsubscribe: function () {
        if (this._subscription) {
            // unsubscribe
            this._subscription.removeListener(this._subscriptionTopic, this._listener);
            this._subscription = undefined;
        }
    },

    _replay: function (event) {
        var that = this;
        return function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift(event);
            that.emit.apply(that, args);
        };
    },

    close: function close(next) {
        this.unsubscribe();
        this._gracefulShutdown(next);
    },

    _filterEventsFromQueue: function (streamX) {
        //Filter out events from queue in case of queue length >=20k and after 3 reconnects
        //10 threads * 20k limit/queue = 200k
        if (streamX.reconnects > 2 && streamX._queue.length > 20000) {
            streamX._queue = streamX._queue.filter(function (eventArgs) {
                return eventArgs.messageClass !== constants.MessageClass.EVENT;
            });
            streamX.reconnects = 1; //resetting reconnects to 1 to avoid frequent filtering
            debug('reducing stream queue for poolId: %s, new queue size: %s',
                streamX.poolId, streamX._queue.length);
        }
    },

    _createNewWriteStream: function (streamX) {
        if (!streamX._queueWrites) {
            return;
        }
        debug('forcing new stream create');
        _closeStream(streamX);
        // update options in case they have changed so that during re-creation of the stream
        // they are picked up
        streamX.options = this._options;
        streamX.writerOptions = streamX.options.writerOptions || {};
        streamX.format = streamX.options.formatter.format;
        streamX.reconnects++;
        debug('poolId %s reconnect %s ', streamX.poolId, streamX.reconnects);
        this._filterEventsFromQueue(streamX);
        streamX.stream = streamX.options.writer.createWriteStream(streamX.writerOptions);
        this._onDrain(streamX);
    },

    _timerForNoDrain: function (streamX) {
        if (!streamX._timer) {
            //If no drain in 10s, create a new writeStream
            streamX._timer = setTimeout(this._createNewWriteStream.bind(this, streamX), 10000);
            streamX._timer.unref();
        }
    },

    _getStream: function (eventArgs) {
        var options, streamX,
            writerOptions, threadId,
            poolId = 0;

        threadId = eventArgs.threadId || 1;
        poolId = (parseInt(threadId / (this._poolSize / 2), 10) % this._poolSize) || 0;
        streamX = calStreamPool.get(poolId);
        if (!streamX) {
            options = this._options;
            writerOptions = options.writerOptions || {};

            streamX = {};
            streamX.options = options;
            streamX.poolId = poolId;
            streamX.format = options.formatter.format;
            streamX.writerOptions = writerOptions;
            streamX.stream = streamX.options.writer.createWriteStream(streamX.writerOptions);
            streamX.reconnects = 0;
            streamX._queueWrites = false;
            streamX._awaitingDrain = false;
            streamX._queue = [];
            calStreamPool.set(poolId, streamX);

            debug('new streamX', poolId, options);
        }
        return streamX;
    },

    _writeOnce: function writeOnce(eventArgs) {
        var streamX = this._getStream(eventArgs);

        var _domain = domain.create();
        _domain.add(streamX.stream);
        _domain.on('error', this._replay('error'));
        _domain.run(function () {
            this._writeToStream(streamX, eventArgs);
        }.bind(this));
    },

    _writeToStream: function writeToStream(streamX, eventArgs) {

        if (!streamX._queueWrites) {
            // Write message, paying attention to backpressure
            streamX._queueWrites = !streamX.stream.write(streamX.format(eventArgs));
            if (streamX._timer) {
                streamX._timer.ref();
                clearTimeout(streamX._timer);
                streamX._timer = null;
            }
        } else {
            // Queue the message
            streamX._queue.push(eventArgs);

            if (!streamX._awaitingDrain) {
                // Not listening for drain events, so start. Use `once` since streams can be swapped
                // out at any time. This allows our handler to clean up after itself.
                streamX.stream.once('drain', this._onDrain.bind(this, streamX));
                streamX._awaitingDrain = true;
                this._timerForNoDrain(streamX);
            }
        }

    },

    _onDrain: function (streamX) {
        streamX._queueWrites = false;
        streamX._awaitingDrain = false;

        // Start processing the queue
        var _domain = domain.create();
        _domain.add(streamX.stream);
        _domain.on('error', this._replay('error'));
        _domain.run(function () {
            while (streamX._queue.length && !streamX._queueWrites) {
                this._writeToStream.call(this, streamX, streamX._queue.shift());
            }
        }.bind(this));

        if (!streamX._queue.length) {
            debug('backlog is empty');
            this.emit(constants.EVENT_QUEUE_EMPTY);
            return;
        }

        if (streamX._queue.length && !streamX._awaitingDrain) {
            // There's still a queue to be processed, but no `drain` handler, so add one.
            streamX.stream.once('drain', this._onDrain.bind(this, streamX));
            streamX._awaitingDrain = true;
            this._timerForNoDrain(streamX);
        }
    },

    _shutdownStream: function (next) {
        var self = this;
        async.times(this._poolSize, function (threadId, cb) {
            var streamX = calStreamPool.get(threadId);
            if (streamX && streamX.stream && streamX.stream.shutdown) {
                streamX.stream.shutdown(cb);
            } else {
                cb();
            }
        }, function (err, results) {
            // reset the streamPool
            calStreamPool.reset();

            var writeStream = self.options.writeStream;
            if (writeStream && writeStream.shutdown) {
                writeStream.shutdown(next);
            } else {
                next && next();
            }
        });
    },

    _gracefulShutdown: function gracefulShutdown(ctx, next) {
        next = arguments[arguments.length - 1];
        ctx = arguments.length > 1 ? ctx : {};

        var size = this.size;
        if (size && (!ctx.prevSize || ctx.prevSize > size)) {
            ctx.prevSize = size;
            debug('waiting for backlog to clear up, size: ', size);
            // queue is being procssed
            if (!ctx.timer) {
                this.once(constants.EVENT_QUEUE_EMPTY, function () {
                    clearTimeout(ctx.timer);
                    this._shutdownStream(next);
                }.bind(this));
            }
            ctx.timer = setTimeout(this._gracefulShutdown.bind(this, ctx, next), 5000);
        }
        else {
            if (size) {
                debug('queue timeout, elements in queue: ', size);
                this._queue = [];
                this.emit('error', new Error('queue timed out, queue size: ' + size));
            }
            this._shutdownStream(next);
        }
    }
});

function debugArgs(suffix, eventArgs) {
    debuggers[suffix] = debuggers[suffix] || require('debug')('cal:queue' + suffix);
    debuggers[suffix]('%s - %s|%s|%s - %s::%s::%s',
        eventArgs.messageClass,
        eventArgs.threadId,
        eventArgs.eventId,
        eventArgs.parentEventId,
        eventArgs.type,
        eventArgs.name,
        eventArgs.status);
}
