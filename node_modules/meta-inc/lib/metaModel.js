'use strict';

var SECONDS_PER_DAY = 86400,
    SECONDS_PER_HOUR = 3600,
    SECONDS_PER_MINUTE = 60;

var os = require('os'),
    fs = require('fs'),
    path = require('path'),
    tryRequire = require('try-require'),
    root = process.cwd(),
    util = require('util'),
    pkgJson = require(path.join(root, 'package.json'));

var aggregatedModules = [];

// Builds the model of all meta information
exports.getModel = function getModel(req, res, model, callback) {
    var stack,
        pageInfo = res.locals && res.locals.context && res.locals.context.pageInfo;

    model.ip = getIPAddress();
    model.scm = (pageInfo && pageInfo.debug && pageInfo.debug.scm) || {};
    model.appInfo = (pageInfo &&  pageInfo.debug && pageInfo.debug.version) || {};
    model.appInfo.appName = req.appName || (pkgJson && pkgJson.name) || '';

    var root = process.cwd(),
    manifestJson = tryRequire(path.join(root, 'manifest.json'));

    // For PayPal, ppcommons has all this data in pageInfo.debug.scm. For
    // eBay, there is no ppcommons so we generate it here.
    if (manifestJson) {
      model.scm =  manifestJson.scm;
      model.appInfo.buildId = manifestJson.version.buildId;
      model.appInfo.buildTimestamp = manifestJson.version.buildTimestamp;
      model.appInfo.appName = manifestJson.info.appName;
      model.appInfo.appVersion = manifestJson.version.appVersion;
      model.appInfo.frameworkName = manifestJson.version.frameworkName;
      model.appInfo.frameworkVersion = manifestJson.version.frameworkVersion;
    }


    model.hostname = os.hostname();
    model.memory = getUsage();
    model.processInfo = getProcessInfo();
    stack = req.app && req.app._router && req.app._router.stack;
    stack = req.routeStack || stack;
    moduleAggregator(function (err, result) {
        if (!err) {
            getMiddlewareAndRoutes(stack, model,
              function (err, model) {
                model.pkg = result; // add packages last so they display last
                return callback(null, model);
              });
        }
    });
};

/**
 * initial invocation to aggregate module information
 * @param callback - callback when done
 */

function moduleAggregator(callback) {
    var dep = pkgJson.dependencies,
        mod,
        size = 0,
        counter = 0,
        pkg = {};

    if (aggregatedModules.length > 0) {
        return callback(null, aggregatedModules);
    }

    Object.keys(dep).forEach(function (key) {
        size++;
        var modPath = path.join(root, 'node_modules', key, 'package.json');
        fs.exists(modPath, function (exists) {
            counter++;
            if (exists) {
                pkg = {};
                mod = require(modPath);
                pkg.name = mod.name;
                pkg.version = mod.version;
                aggregatedModules.push(pkg);
            }
            if (counter === size) {
                callback(null, aggregatedModules);
            }
        });

    });
}

/**
 * function that returns the memory usage details for the app
 */
var getUsage = function () {
    var data = {},
        mem;

    mem = util.inspect(process.memoryUsage());
    data.total = parseInt(mem.split(' ')[4].replace(/,+$/, ""), 10);
    data.used = parseInt(mem.split(' ')[6], 10);
    return data;
};

/**
 * function to obtained the various process related information
 */
var getProcessInfo = function () {
    var totalSec = process.uptime(),
        days = Math.floor(totalSec / SECONDS_PER_DAY),
        hours = Math.floor((totalSec % SECONDS_PER_DAY) / SECONDS_PER_HOUR),
        minutes = Math.floor(((totalSec % SECONDS_PER_DAY) % SECONDS_PER_HOUR) / SECONDS_PER_MINUTE),
        seconds = totalSec % 60,
        sec = seconds.toFixed(),
        result = days + ' days ' + hours + ' hrs ' + minutes + ' min ' + sec + ' secs ',
        process_info = {};

    process_info.uptime = result;
    process_info.deployEnv = process.env.DEPLOY_ENV;
    process_info.nodeEnv = process.env.NODE_ENV;
    process_info.platform = process.platform;
    process_info.architecture = process.arch;
    process_info.cwd = process.cwd();
    return process_info;
};

/**
 * Obtains the middleware and routes  that are configured for the app
 * @param stack argument containing the app.stack information
 * With Express 4 middleware and routes are together so this
 * function handles both conveniently.
 * @model argument gets properties populated.
 */
function getMiddlewareAndRoutes(stack, model, callback) {

    var mware = [],
        routes = {},
        path,
        name,
        fn;

    for (var i in stack) {
        if (!stack[i].route) {
            fn = String(stack[i].handle);
            name = ((fn.substr(0, fn.indexOf('('))).split(" ")[1]);
            if (name !== '') {
                mware.push(name);
            } else {
                mware.push('No Name');
            }
            if (name === 'router') {
                model.routes = getRoutesFromRouter(stack[i].handle.stack, routes);
            }
        } else {
            path = stack[i].route.path;
            routes[path] = [];
            for (var j = 0; j < stack[i].route.stack.length; j++) {
                routes[path].push(stack[i].route.stack[j].method);
            }
        }
    }
    // Set accumulated middleware and route information
    model.middleware = mware;
    model.routes = routes;

    // Handle case where meta-router might be used
    getMetaRouterRoutes(model, routes, callback);
}

function getMetaRouterRoutes(model, routes, callback) {
  var routePath;

  var metaRouter = tryRequire('meta-router');
  // Seems like require.resolve finds the ^1 version but we need
  // an api in the ^2 version. Force it with normal require.
  if (metaRouter) {
    metaRouter = require('meta-router');
  }
  var routesPath = path.join(root, 'routes.json');
  if (!metaRouter || !fs.existsSync(routesPath)) {
    return callback(null, model);
  }
  metaRouter.buildMatcher( routesPath,
    function(err, matcher) {
      if (err) {
        return callback(err, model);
      }
      var rts = matcher.routes;
      var rtsLen = rts.length;
      for (var i = 0; i < rtsLen; i++) {
        routePath = rts[i].path;
        routes[routePath] = rts[i].methods;
      }
      model.routes = routes;
      callback(null, model);
    });
}

/**
 * function to obtain the list of routes and their corresponding methods
 * like get, post etc. that has been configured for the app
 */
var getRoutesFromRouter = function getRoutesFromRouter(routes, data) {
    var i,
        j,
        path;

    for (j = 0; j < routes.length; j++) {
        if (routes[j].route) {
            path = routes[j].route.path;
            data[path] = [];
            for (i = 0; i < routes[j].route.stack.length; i++) {
                data[path].push(routes[j].route.stack[i].method);
            }
        }
    }
};

function getIPAddress() {
    var interfaces = require('os').networkInterfaces();
    for (var name in interfaces) {
        var iface = interfaces[name];

        for (var i = 0; i < iface.length; i++) {
            var alias = iface[i];
            if (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {
                return alias.address;
            }
        }
    }
    return '0.0.0.0';
}
